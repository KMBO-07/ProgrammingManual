# ПРАКТИКА 4

- [ПРАКТИКА 4](#практика-4)
  - [Часто используемые, функции которые уже стоило бы поместить в отдельный библиотечный файл](#часто-используемые-функции-которые-уже-стоило-бы-поместить-в-отдельный-библиотечный-файл)
  - [Разбор задачи 11](#разбор-задачи-11)
  - [Разбор задачи 12](#разбор-задачи-12)
  - [Разбор задачи 13](#разбор-задачи-13)
  - [Разбор задачи 14.](#разбор-задачи-14)
  - [Разбор задачи 16](#разбор-задачи-16)

## Часто используемые, функции которые уже стоило бы поместить в отдельный библиотечный файл

```julia
movements!(r::Robot, side::HorizonSide, num_steps::Int) = for _ in 1:num_steps move!(r,side) 

movements!(r::Robot, side::HorizonSide) = while isborder(r,side)==false move!(r,side) end 

function get_num_movements!(r::Robot, side::HorizonSide)
    num_steps = 0
    while isborder(r,side)==false 
        move!(r,side) 
        num_steps += 1    
    end
    return num_steps
end
```
(имена некотрых из этих функций немного отличаются от использовавшихся ранее)

Определения этих функций могут быть помещены в одельный файл, например, назовем его "roblib.jl".
И после этого эти определения могут помещаться в любые другие файлы с помощью функции `include("roblib.jl")`, выполняемой обычно в начале файла. 

## Разбор задачи 11
Задача 11 формулируется следующим образом.
    ДАНО: Робот - в произвольной клетке, где-то между внутренними перегородкаи прямоугольной формы и внешней рамкой поля (прямоугольники могут быть и вырожденными, т.е. представлять собой отрезки)

    РЕЗУЛЬТАТ: Робот - в исходном положении и в 4-х приграничных клетках, 2-е из которых имеют ту же широту, а 2-е - ту же долготу, что и Робот, стоят маркеры.

В отличии от [задачи 5](../lecture-1/Список-задач-1.md) здесь требуется поставить маркеры не в углах поля, а у всех 4-х границ поля на той же широте и долготе, что и клетка с Роботом.

Ясно, что решение этой задачи будет во-многом повторять решение задачи 5, и только при прохождении вдоль периметра поля маркеры нужно поставить в других местах.
Из этого седует вывод, что, решая задачу 5, мы напрасно не выделили некоторые части главной функции в оддельные подпрограммы, т.к. сейчас мы могли бы ими воспользоваться. Сначала мы можем вренуться к задаче 5 и исправить эту недоработку.

Вот так выгледел написанный нами код главной функции в задаче 5:
```julia
function mark_angles(r)
    num_steps=[]
    while isborder(r,Sud)==false || isborder(r,West) # Робот - не в юго-западном углу
        push!(num_steps, get_num_movements!(r, West))
        push!(num_steps, get_num_movements!(r, Sud))
    end
    # УТВ: Робот - в юго-западном углу и в num_steps - закодирован пройденный путь
    for side in (Nord,Ost,Sud,West)
        movements!(r,side)
        putmarker!(r)
    end
    # УТВ: Маркеры поставлены и Робот - в юго-западном углу

    for (i,n) in enumerate(num_steps)
        side = isodd(i) ? Ost : Nord # odd - нечетный
        movements!(r,side,n)
    end
    #УТВ: Робот - в исходном положении
end
```

Теперь мы его перепишем так:

```julia
function mark_angles(r)
    num_steps = through_rectangles_into_angle(r,(Sud,West))
    # УТВ: Робот - в юго-западном углу и в num_steps - закодирован пройденный путь
    for side in (Nord,Ost,Sud,West)
        movements!(r,side) # возвращаемый результат игнорируется
        putmarker!(r)
    end
    # УТВ: Маркеры поставлены и Робот - в юго-западном углу
    movements!(r,(Ost,Nord),num_steps)
    #УТВ: Робот - в исходном положении
end
```
Две новые вспомогательные функции through_rectangles_into_angle, сome_back, как мы убедились, имеют достаточно универсальный характер, и мы их поместим в наш библиотечный файл "roblib.jl", наряду с другими уже имещимися там функциями.
Вот код этих новых функций:
```julia
"""
    through_rectangles_into_angle(r,angle::NTuple{2,HorizonSide})

-- Перемещает Робота в заданный угол, прокладывая путь межу внутренними прямоугольными перегородками и возвращает массив, содержащий числа шагов в каждом из заданных направлений на этом пути
"""
function through_rectangles_into_angle(r,angle::NTuple{2,HorizonSide})
    num_steps=[]
    while isborder(r,angle[1])==false || isborder(r,angle[2]) # Робот - не в юго-западном углу
        push!(num_steps, movements!(r, angle[2]))
        push!(num_steps, movements!(r, angle[1]))
    end
    return num_steps
end

"""
    movements!(r,sides,num_steps::Vector{Int})

-- перемещает Робота по пути, представленного двумя последовательностями, sides и num_steps 
-- sides - содержит последовательность направлений перемещений
-- num_steps - содержит последовательность чисел шагов в каждом из этих направлений, соответственно; при этом, если длина последовательности sides меньше длины последовательности num_steps, то предполагается, что последовательность sides должна быть продолжена периодически        
"""
function movements!(r,sides,num_steps::Vector{Int})
    for (i,n) in enumerate(num_steps)
        movements!(r, sides[mod(i-1, length(sides))+1], n)
    end
end
```

Теперь мы можем легко записать и решение задачи 11.

```julia
function mark_centers(r)
    num_steps = through_rectangles_into_angle(r,(Sud,West))
    # УТВ: Робот - в юго-западном углу и в num_steps - закодирован пройденный путь
    num_steps_to_ost = sum(num_steps[1:2:end])
    num_steps_to_nord = sum(num_steps[2:2:end])

    #---------------------
    movements!(r,Nord,num_steps_to_nord)
    putmarker!(r)
    num_steps_to_sud = movements!(r,Nord)

    movements!(r,Ost,num_steps_to_ost)
    putmarker!(r)
    num_steps_to_west = movements!(r,Ost)

    movements!(r,Sud,num_steps_to_sud)
    putmarker!(r)
    movements!(r,Sud) # возвращаемое значение игнорируется

    movements!(r,Sud,num_steps_to_west)
    putmarker!(r)
    movements!(r,Sud) # возвращаемое значение игнорируется
    # УТВ: Маркеры поставлены и Робот - в юго-западном углу
    #-------------------

    movements!(r,(Ost,Nord),num_steps)
    #УТВ: Робот - в исходном положении
end
```
Остается только, может быть, пояснить, что означают
```julia
sum(num_steps[1:2:end])
sum(num_steps[2:2:end])
```
Во-первых, `num_steps[1:2:end]` - это "срез" массива `num_steps`, т.е. массив, состоящий из `num_steps[1]`, `num_steps[3]`, `num_steps[5]` и т.д., т.е. - из всех элементов на нечетных позициях (войдет или не войдет последний элемент исходного массива в этот срез - зависит от длины массива). Аналогично, `num_steps[2:2:end]` - это "срез" того же массива, но содержащий все элементы с четных позиций.

Во-вторых, `sum` - это встроенная функция, которая получает на вход массив и возвращает сумму его элементов.

## Разбор задачи 12

УСЛОВИЕ.На прямоугольном поле произвольных размеров расставить маркеры в виде "шахматных" клеток, начиная с юго-западного угла поля, когда каждая отдельная "шахматная" клетка имеет размер n x n клеток поля (n - это параметр функции). Начальное положение Робота - произвольное, конечное - совпадает с начальным. Клетки на севере и востоке могут получаться "обрезанными" - зависит от соотношения размеров поля и "шахматных" клеток.

Подсказка: здесь могут быть полезными две глобальных переменных, в которых будут содержаться текущие декартовы координаты Робота относительно начала координат в левом нижнем углу поля, например.

Воспользуемся этой подсказкой и спроектруем модуль с двумя глобальными переменными, которые будут содержать текущие декартовы координаты Робота. Начало координат поместим в левый нижний угол поля, а оси координат направим параллельно границам поля вправо и вверх, соответственно.

```julia
module NNChessMarker
    export mark_chess

    X_COORDINATE=0
    Y_COORDINATE=0

    CELL_SIZE = 0 # - размер "шахматной" клеки 

    function mark_chess(r::Robot,n::Int)
        global CELL_SIZE
        CELL_SIZE = n # инициализация глобальной переменной

        #УТВ: Робот - в юго-западном углу
        side=Ost
        mark_row(r,side)
        while isborder(r,Nord)==false
            move_decart!(r,Nord)
            side = inverse(side)
            mark_row(r,side)
        end
    end

    function mark_row(r::Robot,size::HorizonSide)       
        putmarker_chess!(r)
        while isborder!(r,side)==false
            move_decart!(r,side)
            putmarker_chess!(r)
        end
    end

    function putmarker_chess!(r)
        if (mod(X_COORDINATE, 2*CELL_SIZE) in 0:CELL_SIZE-1) 
                && (mod(Y_COORDINATE, 2*CELL_SIZE) in 0:CELL_SIZE-1) 
            putmarker!(r)
        end
    end

    function move_decart!(r,side)
        global X_COORD, Y_COORD
        if side==Nord
            Y_COORD+=1
        elseif side==Sud
            Y_COORD-=1
        elseif side==Ost
            X_COORD+=1
        else # side==West
            X_COORD-=1
        end
        move!(r,side)
    end

end
``` 
Как использовать модуль - об этом рассказывалось в [Лекции 3](../3/Лекция-3.md), в подразделе "Пример программы, использующей глобальную переменную"

## Разбор задачи 13
Формулировка задачи 13
    ДАНО: Робот - в произвольной клетке ограниченного прямоугольной рамкой поля без внутренних перегородок и маркеров.

    РЕЗУЛЬТАТ: Робот - в исходном положении в центре косого креста (в форме X) из маркеров.

Подсказка: решение будет подобно решению задачи 1, если направление премещения Робота задавать кортежами пары значений типа HorizonSide.

Воспользовавшись подсказкой, можем получить следующий код, дающий решение задачи 13.

```julia
function mark_kross_x(r::Robot)
    for side in ((Nord,Ost),(Sud,Ost),(Sud,West),(Nord,West))
        putmarkers!(r,side)
        move_by_markers!(r,inverse(side))
    end
    putmarker!(r)
end

putmarkers!(r::Robot,side::NTuple{2,HorizonSide}) = while isborder(r,side)==false move!(r,side) end

isborder(r::Robot,side::NTuple{2,HorizonSide}) = (isborder(r,side[1] || isborder(r,side[2]))

HorizonSideRobots.move!(r::Robot, side::NTuple{2,HorizonSide}) = for s in side move!(r,s) end
# Здесь мы переопределяем одноименную стандартную команду Робота, определенную в модуле HorizonSideRobots 
# (важно, что в новом определении аргумент side имеет другой тип, отличный от соответствующего типа
# в стандартной команде), и поэтому в этом определении нам пришлось использовать составное имя: 
# HorizonSideRobots.move!

move_by_markers!(r::Robot,side::NTuple{2,HorizonSide}) = while ismarker(r) move!(r,side) end

inverse(side::NTuple{2,HorizonSide}) = (inverse(side[1]),inverse(side[2]))
```

## Разбор задачи 14.
```julia
    # На поле возможны внутренние перегородки ПРЯМОУГОЛЬНОЙ формы (допускаются и вырожденные прпямоугольники, т.е. - отрезки)
    function mark_kross(r)
        for side in (Nord, West, Sud, Ost)
            num_steps = putmarkes!(r,side)
            move!(r,inverse(side), num_steps)
        end
    end


    function putmarkers!(r::Robot,side::HorizonSide)
        num_steps=0 
        while move_if_possible!(r, side) == true
            putmarker!(r)
            num_steps += 1
        end 
        return num_steps
    end
```
Если сравнить это с решением задачи 1 ([см. Лекция 1](../lecture-1/Лекция-1.md)),
то можем заметить, что до сих пор решения практически совпадают, за исключением того, что теперь мы решили считать число шагов, которые Робот делает от исходного положения до внешней границы в каждом из 4-х направлений (но мы и при решении задачи 1 тоже должны были бы так делать, если бы на поле изначально допускалось наличие каких-то маркеров, см. [формулировку задачи 1](../lecture-1/Список-задач-1.md)).

Но принципиальные отличия будут уже только в функциях move_is_posible и move!(::Robor,::HorizonSide,::Int), в которых теперь надо реализовать обход внутренних перегородок, если они встечаются на пути.

```julia
    # Перемещает робота в заданном направлении, если это возможно, и возвращает true,
    # если перемещение состоялось; в противном случае - false.
    function move_if_possible!(r::Robot, side::HorizonSide)::Bool
        orthogonal_side = next(side)
        reverse_side = reverse(orthogonal_side)
        num_steps=0
        while isborder(direct_side) == true
            if isborder(r, orthogonal_side) == false
                move(r, orthogonal_side)
                num_steps += 1
            else
                break
            end
        end
        #УТВ: Робот или уперся в угол внешней рамки поля, или готов сделать шаг (или несколько) в направлении 
        # side
        if isborder(r,side) == false
            while isborder(r,reverse_side) == true
                move!(r,side)
            end
            result = true
        else
            result = false
        end
        move!(r,reverse_side)
        return result
    end

    # Делает заданное число шагов в заданном направлении, при необходимости обходя внутренние перегородки.
    # При этом величина одного "шага" может быть больше 1 и равна "толщине" встретившейся прямоугольной 
    # перегородки
    movements!(r::Robot, side::HorizonSide, num_steps::Int) =
    for _ in 1:num_steps
        move_if_posible!(r,side) # - в данном случае возможность обхода внутренней перегородки гарантирована
    end
```

## Разбор задачи 16
Требуется замаркировать все доступные клетки поля с внутренними перегородками прямоугольной формы (вырожденные прямоугольники допускаются) и вернуть Робота в исходное положение.

Для решения этой задачи мы можем воспользоваться функциями through_rectangles_into_angle, сome_back из задачи 11, которые позволяют переместить робота в юго-западный угол, а затем, после выполнения основной задачи, и перемещения Робота снова в юго-западный угол вернуть его обратно. Поэтому сосредоточимся исключительно на решении основной задачи, которая будет формулироваться следующим образом.

ДАНО: Робот - в юго-западном углу прямоугольного поля с прямоугольными внутренними перегородками.
РЕЗУЛЬТАТ: Робот - у северной границы поля и все доступные клетки поля замаркированы.

Решение этой задачи дает следующий код.
```julia
function mark_field(r)
    side=Ost
    mark_row(r,side)
    # ИНВАРИАНТ: горизонталный ряд с роботом и все нижние ряды замаркированы (замаркированы все из доступные 
    # клетки)
    while isborder(r,side)==false
        move!(r,Nord)
        side=inverse(side)
        mark_row(r,side)
    end
    #УТВ: Робот - у северной границы
end


function mark_row(r::Robot,side::HorizonSide)
    putmarker!(r)
    # ИНВАРИАНТ: клетка с роботом и все ДОСТУПНЫЕ предыдущие в данном ряду (по ходу движения) замаркированы
    while move_if_posible!(r,side) == true
        putmarker!(r)
    end
end
```
Функция move_if_posible! была реализована при решении задачи 14.

ЗАМЕЧАНИЕ. При решении этой задачи можно было бы также сначала переместить Робота в северо-восточный угол поля, затем перемещать его, сначала на запад до упора, а затем на юг до упора попасть в юго-западный угол, попутно определяя размеры поля, и сохраняя их в сооответствующих глобальных переменных. Затем значения этих переменных можно было бы использовать в другой, альтернативной, реализации функции move_if_posible!. Это бы дало возможность сразу знать, какая перегородка является внутренней и обходится, а какая перегородка является внешней. Но для этого понадобилось бы также всегда перемещать робота с помощью функции move_decart!, разработанной при решении задачи 12. Однако эта функция не отрывна от своего модуля, т.к. она использует глобальные переменные (с текущими координатами Робота), поэтому мы не смогли бы ее импортировать отдельно от ее модуля, а могли бы только  "скопипатить" ее код, что есть не очень хороший подход к программированию. Но выйти из такого положения можно, отказавшись от использования модулей в полльзу проектирования пользовательских типов, о чем речь еще будет впереди.
