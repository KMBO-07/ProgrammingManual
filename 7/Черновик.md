
```julia
putmatkers!(robot, side) = movements!(robot, side)
move!(robot,side) = begin HorizonSideRobots.move!(robot,side); putmarker!(robot) end
```

В результате последнего определения в текущем пространстве имен появится новое определение функции `move!`, а в пространстве имен `HorizonSideRobots` остается прежнее. Плохо в этом решении также то, что для его реализации мы были вынуждены держать в голове внутреннее устройство функции `movements!(robot, side)`, помнить что в ней используется функция с именем `move!`, которую теперь надо переопределить. Тут еще хуже то, что при таком подходе получается, что поведение функции `movements!(robot, side)` завистит от контекста, и это идет в разрез с желанием рассматривать функции как независимые элементы для построения программы.

Но пока что в этом нет ни какого функционального программирования, мы определили обычные функции, т.е. это не функции высшего порядка.

От указанных недостатков можно избавиться, например, если использовать функции высшего порядка, следующим образом:

```julia
function putmarkers!(robot)
    move!() = begin move!(robot,side); putmarker!(robot) end
    return side -> movements!(move!, ()->!isborder(robot, side))
end
```

где ранее было определено:

```julia
movements!(move!::Function, move_condition::Function) = while move_condition() move() end
```

Полученная функция не выполняет ни каких реальных действий, она только возвращает замыкание своего аргумента, т.е. значение функционального типа (функцию).

Получаемое с ее помощью замыкакние является функцией одного аргумента (мы его называем для ясности `side`, но это просто формальный параметр замыкания).

Теперь, чтобы совершить нужные нужные действия, эту получаемую функцию потребуется вызваать с нужным фактическим параметром (`side`), т.е.

```julia
#=
Предполагается, что определено конкретное значение переменной side, а переменная robot содержит ссылку на конкретного Робота
=#

func=putmarkers!(robot)
func(side)
```

Но то же самое можно было бы сделать и без использования промежуточной переменной func:

```julia
putmarkers!(robot)(side) # это тоже самое, что и (putmarkers!(robot))(side)
```

Теперь сделаем для нашего решения "обертку", что бы получить соответствующую функцию (обычную) с аргументами `robot` и `side`, которую можно было бы в последствии использовать многократно:


```julia
function putmarkers!(robot,side)
    function putmarkers!(robot) # возвращает замыкание своего аргумента

        function move_to_border(side)  
            movements!(()->!isborde(robot,s)) do 
                move!(robot,side)
                putmarker!(robot)
            end
        end

        return move_to_border
    end

    return putmarkers!(robot)(side)
    # возвращается результат вызова замыкания аргумента robot на исполнение с фактическим параметром side
end
```
