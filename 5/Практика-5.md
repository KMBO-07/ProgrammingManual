- [Создание библиотечного файла roblib.jl](#создание-библиотечного-файла-roblibjl)
- [Пример, когда желание иметь универсальный код приводит к необходимости, некоторые вспомогательные функции распределять по нескольким отдельным файлам](#пример-когда-желание-иметь-универсальный-код-приводит-к-необходимости-некоторые-вспомогательные-функции-распределять-по-нескольким-отдельным-файлам)
  
## Создание библиотечного файла roblib.jl

Подытожим результаты всей предыдущей работы по решению задач. 

У нас уже накопилось не мало вспомогательных функции, которые встречались из задачи в задачу. 

Поэтому эти функции являются претендентами на включение их в состав специальной библиотеки, например, -  в файл `librob.jl`

Вспомним их еще раз.

```julia
#Cодержимое файла roblib.jl

"""
    movements!(r::Robot, side::HorizonSide, num_steps::Int)

-- Перемещает Робота в заданном направлении на заданное число шагов    
"""
movements!(r::Robot, side::HorizonSide, num_steps::Int) = for _ in 1:num_steps move!(r,side) 

"""
    movements!(r::Robot, side::HorizonSide)

-- Перемещает Робота в заданном направлении до упора    
"""
movements!(r::Robot, side::HorizonSide) = while isborder(r,side)==false move!(r,side) end 


"""
    get_num_movements!(r::Robot, side::HorizonSide)

-- Перемещает Робота в заданном направлении до упора и возвращает сделанное число шагов    
"""
function get_num_movements!(r::Robot, side::HorizonSide)
    num_steps = 0
    while isborder(r,side)==false 
        move!(r,side) 
        num_steps += 1    
    end
    return num_steps
end

"""
    inverse(side::HorizonSide)

-- Возвращает направление, противоположное заданному    
"""
inverse(side::HorizonSide) = HorizonSide(mod(Int(side)+2, 4))

"""
    left(side::HorizonSide)

-- Возвращает направление, следующее, если отсчитывать против часовой стредки, по отношению к заданному    
"""
left(side::HorizonSide) =  HorizonSide(mod(Int(side)+1, 4))
# - прежде было имя next, но все-таки будет существенно удобнее, если его заменить на  lef (это будет яснее)

"""
    right(side::HorizonSide)

-- Возвращает направление, предыдущее, если отсчитывать против часовой стредки, по отношению к заданному    
"""
right(side::HorizonSide) = HorizonSide(mod(Int(side)-1, 4))
```

Для того, чтобы иметь возможность пользоваться встроенной системой помощи все библиотечные функции следует предварять описаниями в виде многостирочного комментария, заключамого в тройные кавычки """....""". Тогда, после выполнения вклчения `include(имя_файла)` в REPL можно будет получить информацию о любой функции (с описанием) из данного файла:

```julia
julia>? имя_функции
```

В результате, все функции, составляющие нашу библиотеку, могли бы быть использованы во всех рассматривавшихся задачах (1-25) с помощью выполнения включения `include("roblib.jl")` в файлы с новыми программами.

## Пример, когда желание иметь универсальный код приводит к необходимости, некоторые вспомогательные функции распределять по нескольким отдельным файлам

Однако встречались и функции с одинаковыми именами, которые в разных задачах приходилось переопределять, потомучто требовалось учитывать специфику каждой задачи.
А именно, вспомним [задачу 14](../4/Задачи%2014-25.md), которая есть аналог [задачи 1](../lecture-1/Список-задач-1.md), но ее уловие допускает наличие на поле внутренних перегодок прямоугольной формы. Решение этой задачи было разобрано в [Практика 4](../4/Практика-4.md) (напомним, там требовалось расставить маркеры в форме прямого креста).

Сравнивая оба решения мы видим, что следующий код:

```julia
    function mark_kross(r)
        for side in (Nord, West, Sud, Ost)
            num_steps = putmarkes!(r,side)
            movements!(r,inverse(side), num_steps) # тут шибочно было: move!(...)
        end
    end

    function putmarkers!(r::Robot,side::HorizonSide)
        num_steps=0 
        while move_if_possible!(r, side) == true
            putmarker!(r)
            num_steps += 1
        end 
        return num_steps
    end

    movements!(r::Robot, side::HorizonSide, num_steps::Int) =
    for _ in 1:num_steps
        move_if_posible!(r,side) # - в данном случае возможность обхода внутренней перегородки гарантирована
    end
```

может давать решение как задачи 1, так и задачи 14 - тут все зависит от того, как будет реализована вспомогательная функция `move_if_posible!(::Robot, ::HorizonSide)`.

Eсли

```julia
move_if_possible!(r::Robot, side::HorizonSide) =
    if isborder(r,side)==false
        move!(r,side)
        return true
    else
        return false
    end
```

то получим решение задачи 1. Кстати говоря, это определение можно было бы записать и в одну строчку

```julia
move_if_possible!(r::Robot, side::HorizonSide) = !isborder(r,side) ? (move!(r,side); true) : false
```

где `(move!(r,side); true)` - это не кортеж, в кортеже элементы разделяются запятой, это программный блок, и это эквивалентно `begin move!(r,side); true end`.

Соответственно в случае задачи 14, эта функция будет уже иметь другую реализацию: 

```julia
"""
    move_if_possible!(r::Robot, side::HorizonSide)::Bool

-- Перемещает Робота в заданном направлении на 1 шаг и возвращает true - это, если мешающей перегородки нет, 

или, если её можно обойти; имеется ввиду, что изолированная перегородка прямоугольной формы. 

В противном случае Робот остается на месте и функция возвращает false.
"""
function move_if_possible!(r::Robot, direct_side::HorizonSide)::Bool
    orthogonal_side = left(direct_side)
    reverse_side = inverse(orthogonal_side)
    num_steps=0
    while isborder(r,direct_side) == true
        if isborder(r, orthogonal_side) == false
            move!(r, orthogonal_side)
            num_steps += 1
        else
            break
        end
    end
    #УТВ: Робот или уперся в угол внешней рамки поля, или готов сделать шаг (или несколько) в направлении 
    # side

    if isborder(r,direct_side) == false
        move!(r,direct_side)
        while isborder(r,reverse_side) == true
            move!(r,direct_side)
        end
        result = true
    else
        result = false
    end
    for _ in 1:num_steps
        move!(r,reverse_side)
    end
    return result
end
```

(конечно решение задачи 14 включает в себя и решение задачи 1, но если известно, что внутренних перегородок на поле нет, то решение, относящееся к более общему случаю будет содержать в себе лишние проверки, котрые иногда могут быть желательны).

Возникает вопрос, а как воспользоваться замеченным сходством двух алгоритмов, так чтобы не кодировать посути одно и тоже дважды. 

**Решение может состоять в том, чтобы эти две разные реализации функции move_if_possible! поместить в разные файлы, и подключать к файлу с главной функцией тот или иной из них с помощью функции include, в зависимости от решаемой задачи.**

Однако возможен и другой способ решения данной проблемы, основанный на так называемом обобщенном подходе к программированию. 
