------------------------------------------------
------------------------------------------------

ДАЛЕЕ, ВРОДЕ КАК, НИЧЕГО ОСОБЕННО ЦЕННОГО НЕТ

------------------------------------------------

В предыдущих примерах на использование множественной диспетчеризацию, мы описывали типы аргументов функций как можно более точно. Однако, как правило, так поступать не следует, потому что это будет ограничивать область применеия функций.

Например, мы определили один из методов функции move! так
```julia
move!(r::Robot, sides::Tuple{HorizonSide})
```
но могли бы определить и так
```julia
move!(r::Robot,sides::Tuple)
```
Теперь второй аргумент имеет более общий тип - это кортеж (Tuple) каких-угодно значений.
Можно было бы возразить, что какие-угодно значения нам не нужны, у нас есть только Nord, Sud, Ost и West. Но, на самом деле, не исключено, что когда-нибудь могут понадобиться и направления на северо-восток, северо-запад, юго-восток, юго-запад, которые будут определяться кортежами двух соответствующих значений: (Nord,Ost), (Nord, West), (Sud,Ost), (Sud,West) (и мы в этом совсем скоро убедимся).  И тогда замена Tuple{HorizonSide} на Tuple, может оказаться оправданной. 
Но остается еще проблема, при описании sides::Tuple мы можем задать последовательность направлений в виде кортежа направлений, но не можем - в виде массива направлений. Чтобы расширить наши возможности в этом направлении, следовало бы описать функцию вообще без аннотирования типа ее второго аргумента
```julia
move!(r::Robot, sides)
```
На самом деле это просто означает, что sides::Any, где `Any` - это абстрактный тип, стоящий во лаве всей иерархии типов языка Julia. Фактически это означает, что тип второго аргумента может быть любой, за исключением типа HorizonSide, т.к. для этого случая имеется определение отдельного метода функции. При этом говорят, что функция имеет специализацию для типа HorizonSide. 

Точно также, определяя новые методы для функции move!, на самом деле стоит отказаться и от аннотирования первого аргумента:
```julia
move!(r::Robot, side::HorizonSide) # - имеет максимальную специализацию по обоим аргументам
move!(r, side, num_steps) # - тип всех аргументов Any
move!(r, sides) # - тип всех аргументов Any
```

Какую выгоду из этого мы сумеем извлечь - это мы увидим дальше. Но пока просто будем следовать общему принципу: без явной необходимости не сужать специализацию функций.

Иногда такое сужение специализации нежелательно, потому что приведет к ограничению общности функции, а иногда - просто потому, что точное описание типа может оказаться слишком громоздким.

### Примеры разработки обобщенных функций
Рассмотрим еще раз, разобранную ранее, [задачу 13](../4/Практика-4.md).
ДАНО: Робот - в произвольной клетке ограниченного прямоугольной рамкой поля без внутренних перегородок и маркеров.

РЕЗУЛЬТАТ: Робот - в исходном положении в центре косого креста (в форме X) из маркеров.

**Решение**
Следуя технологии "сверху вниз", запишем псевдокод
```julia
for side in ((Nord,Ost),(Nord,West),(Sud,West),(Sud,Ost))
    ставить маркеры в направлении side до упора
    вернуться в обратном направлении по маркерам в исходное положение
end
```
Или придумывая подходящиее заголовки для соответствующих подпрограмм, получаем
```julia
function mark_krest(r,sides)
    for side in sides
        putmarkers!(r,side) # ставит маркеры в заданном напралении до упора
        moves_by_markers!(r,inverse(side)) 
    end
    putmarker!(r) 
end

"""
    inverse(s::HorizonSide)

-- возвращает направление, противоположное заданному    
"""
inverse(s::HorizonSide)=HorizonSide(mod(Int(s)+2,4))

"""
    inverse(side)

-- side - кортеж или вектор, содержащий направления типа Union{HorizonSide, NTuple{2, HorizonSide}}
"""
inverse(side)=typeof(side)((inverse.(collect(side))))

"""
    putmarkers(r,side)

--
"""
putmarkers(r,side) = 
    while isborder(r,side) == true
        move!(r,side)
        putmarker!(r)
    end

"""
    isborder(r,side)

-- r - ссылка на Робота

-- side - итерируемый объект, содержащий значения направлений типа HorizonSize (но формально тут этого ограничения нет)

-- возвращает true, если хотя бы для с одного из направлений в side рядом с роботом имеется перегородка
"""
function isborder(r,side) 
    for s in side
        if isborder(r,s)==true return end
    end
    return false
end

"""
    move!(r,sides)

-- r - ссылка на Робота

-- sides - итерируемый объект, содержащий значения направлений (например, типа HorizonSize)

-- последовательно перемещает робота в направлениях из sides
"""
move!(r,side) = for s in side move!(r,s) end


"""
    moves_by_markers!(r,side)

-- перемещает Робота r в заданном направлении side, до тех пор пока Робот находится в клетке с маркером

-- side::Union{HorizonSide,Ntuple{2,HorizonSide}
"""
moves_by_markers!(r,side) = 
    while ismarker(r,side)
        move!(r, side)
    end
end
```

### Пример практического использования множественной диспетчеризации

И так, у Робота есть команда move!(::Robot, ::HorizonSide), которая перемещает его ровно на одну клетку в заданном направлении, в предположении, конечно, что этому не помешает перегородка. Если же наличествует перегородка на пути, то произойдет фатальная ошибка времени выполнения.

А что если понадобится команда сделать шаг "по диагонали", на северо-восток, юго-восток, и т.д. Какждый такой шаг реализуется за 2 стандартных шага Робота, поэтому соответствующий параметр новой функции, которая это будет реализовывать, задается кортежем (Tuple) вида (Nor,Ost), (Sud,Ost), и т.д.
Но как назвать саму эту функцию? Если использовать множественную диспетчерезацию, то имя этой новой команды может быть тоже move!, что было бы логично (и даже очень желательно, если иметь целью программировать обобщенно, о чем несколько слов здесь будет сказано далее). Для этого только потребуется нужным образом аннотировать тип соответствующего параметра:
```julia
move!(r::Robot,side::Tuple{HorizonSide}) = for s in side move!(r,s) end
```
Теперь можно будет командовать, например, так:
```julia
move!(r,(Nord,Ost))
```

Но можно также и
```julia
move!(r,(Nord,Sud))
```
но это, скорее всего, бессмысленная команда, т.к. если на пути не было перегородки, то робот просто останется на месте, а если была - то произойдет фатальная ошибка времени выполнения.

Однако возможно будет скомандовать еще и так, например,
```julia
move!(r,(Nord,Nord,Sud,Nord))
```
или
```julia 
move!(r,[Nord,Nord,Sud,Nord])
```
и такая возможность может оказаться очень даже полезной.

Но тут возможен еще такой "фокус".
Мы определили тип аргумента side как Tuple{HorizonSide}, т.е. кортеж (произвольной длины) значений типа HorizonSide. Таким кортежем является, например, (Nord,Nord,Sud,Nord), который содержит в себе некоторый "путь" для Робота. А что если бы мы захотели задать такой путь: ((Nord,Ost),(Sud,West),(Sud,Ost)), то чтобы заставить Робота пройти этот путь, уже нельзя будет воспользоваться функцией move!(::Robot,::Tuple{HorizonSide}), потому что этому не соответствует тип ее вторго параметра. Но предвидя такую задачу, мы могли бы аннотировать этот аргумент так
```julia
move!(r::Robot,side::Tuple) = for s in side move!(r,s) end
``` 
Теперь тип аргумента side есть кортеж (произвольной длины) каких угодно значений, в том числе допусимыми будут и значения вида (Nord,Ost),(Sud,West),(Sud,Ost). 

Это есть небольшая иллюстрация касающаяся **обобщенного программирования**.

Можно даже было бы вообще не аннотировать аргументы этой функции:
```julia
move!(r,side) = for s in side move!(r,s) end
```
и тем самым повысить степень ее обобщенности. 

Где достигаемая таким способ обобщенность может пригодиться, часто заранее даже не известно.
Но в рассмативаемом случае сразу можно сказать, где она будет полезна. В самом деле, теперь последовательность направлений может быть представлена не только кортежем соответствующих значений, но и вектором этих значений, например: [(Nord,Ost),(Sud,West),(Sud,Ost)], или - [Nord,Nord,Sud,Nord].

На самом деле, не явно типы аргуметнов нашей последней функции аннотированы, можно считать, типом Any. Any - это абстрактный тип, стоящий на вершине иерархии всех типов Julia.

Но для того, чтобы работала множественная диспетчеризация достаточно, чтобы в одном случае был один тип, в нашем случае HorizonSide, а в другом - тип может быть и Any (важно, что какой-то другой).
