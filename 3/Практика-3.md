# ПРАКТИКА 3

- [ПРАКТИКА 3](#практика-3)
  - [**Разбор решения задачи 5**](#разбор-решения-задачи-5)
    - [**Возможный вариант решения задачи 5**](#возможный-вариант-решения-задачи-5)
    - [**Улучшенный вариант решения задачи 5**](#улучшенный-вариант-решения-задачи-5)
  - [**Разбор решения задачи 8**](#разбор-решения-задачи-8)
    - [**Первый вариант решения задачи 8**](#первый-вариант-решения-задачи-8)
    - [**Второй вариант решения задачи 8**](#второй-вариант-решения-задачи-8)
  - [**Разбор решения задачи 9**](#разбор-решения-задачи-9)
  
## **Разбор решения задачи 5**
    ДАНО: Робот - в произвольной клетке ограниченного прямоугольного поля, на котором могут находиться также внутренние прямоугольные перегородки (все перегородки изолированы друг от друга, прямоугольники могут вырождаться в отрезки) 
   
    РЕЗУЛЬТАТ: Робот - в исходном положении и в углах поля стоят маркеры

### **Возможный вариант решения задачи 5**
```julia
function mark_angles(r)
    num_steps=[]
    while isborder(r,Sud)==false || isborder(r,West) # Робот - не в юго-западном углу
        push!(num_steps, moves!(r, West)) # - добавляется в конец массива новый элемент
        push!(num_steps, moves!(r, Sud))
    end
    # УТВ: Робот - в юго-западном углу и в num_steps - закодирован пройденный путь
    for side in (Nord,Ost,Sud,West)
        moves!(r,side) # возвращаемый результат игнорируется
        putmarker!(r)
    end
    # УТВ: Маркеры поставлены и Робот - в юго-западном углу
    for (i,n) in enumerate(reverse!(num_steps)) # встроенная функция reverse! переворачивает массив задом на перед
        side = isodd(i) ? Ost : Nord # odd - нечетный
        moves!(r,side,n)
    end
    #УТВ: Робот - в исходном положении
end

#=
Последний цикл в этой функции эквивалентен следующему:

    i=0
    for n in num_steps
        i+=1
        side = isodd(i) ? Ost : Nord # odd - нечетный
        moves!(r,side,n)
    end

=#

# перемещает Робота в заданном направлении до упора и возвращает число сделанных шагов
function moves!(r,side)
    num_steps=0
    while isborder(r,side)==false
        move!(r,side)
        num_steps+=1
    end
    return num_steps
end

# Перемещает Робота в заданном направлении на заданное число шагов
moves!(r,side,num_steps) = for _ in 1:num_steps move!(r,side) end
```
ЗАМЕЧАНИЕ.
Имя последней функции moves! отличается одной буквой от имени стандартной команды Робота move!. 
Но, в принципе, эту функцию мы могли бы тоже назвать move!, но тогда пришлось бы написать так
```julia
HorizonSideRobots.move!(r,side,num_steps)=for _ in 1:num_steps move!(r,side) end
```
Это ознало бы, что мы переопределяем страндартную команду Робота move! (но для другого числа аргументов). В этом случае язык Julia требует, чтобы при таком переопределении использовалось расширенное имя с префиксом "HorizonSideRobots.", определяюшим принадлежность соответствующему модулю.

Ну или можно было бы это переопределение сделать еще и так:
```julia
import HorizonSideRobots.move!
move!(r,side,num_steps)=for _ in 1:num_steps move!(r,side) end
```

Но в данном случае не стали делать такого переопределения.

--------------------------
[<< к началу](#практика-3)

--------------------------
### **Улучшенный вариант решения задачи 5**

Однако в главной функцию можно было бы выполнить еще дополнительную декомпозици: 

```julia
function mark_angles(r)
    num_steps = through_rectangles_into_angle(r,(Sud,West))
    # УТВ: Робот - в юго-западном углу и в num_steps - закодирован пройденный путь
    for side in (Nord,Ost,Sud,West)
        moves!(r,side) # возвращаемый результат игнорируется
        putmarker!(r)
    end
    # УТВ: Маркеры поставлены и Робот - в юго-западном углу
    move!(r,(Ost,Nord),num_steps)
    #УТВ: Робот - в исходном положении
end
```
Здесь выделены еще две новые вспомогательные функции through_rectangles_into_angle, сome_back, котрые, вообще-то, имеют достаточно универсальный характер, и могут пригодиться в будущем (если их поместить в библиотечный файл).

Вот код этих новых функций, с соответствующими описаниями, как это положено для библиотечных функций, чтобы можно было получать по этим функциям информацию с использованием встроенной системы помощи:
```julia
"""
    through_rectangles_into_angle(r,angle::NTuple{2,HorizonSide})

-- Перемещает Робота в заданный угол, прокладывая путь межу внутренними прямоугольными перегородками и возвращает массив, содержащий числа шагов в каждом из заданных направлений на этом пути
"""
function through_rectangles_into_angle(r,angle::NTuple{2,HorizonSide})
    num_steps=[]
    while isborder(r,angle[1])==false || isborder(r,angle[2]) # Робот - не в юго-западном углу
        push!(num_steps, moves!(r, angle[2]))
        push!(num_steps, moves!(r, angle[1]))
    end
    return num_steps
end

"""
    moves!(r,sides,num_steps::Vector{Int})

-- перемещает Робота по пути, представленного двумя последовательностями, sides и num_steps 
-- sides - содержит последовательность направлений перемещений
-- num_steps - содержит последовательность чисел шагов в каждом из этих направлений, соответственно; при этом, если длина последовательности sides меньше длины последовательности num_steps, то предполагается, что последовательность sides должна быть продолжена периодически       
"""
function moves!(r,sides,num_steps::Vector{Int})
    for (i,n) in enumerate(reverse!(num_steps))
        moves!(r, sides[mod(i-1, length(sides))+1], n) # - это не рекурсия (не вызов функцией самой себя), это вызов другой, ранее определенной функции
        # выражение индекса массива mod(i-1, length(sides))+1 обеспечисвает периодическое продолжение последовательности из вектора sides до длины вектора num_steps 
    end
end
```

Здесь важно понять, что определяемая здесь функция moves!(r,sides,num_steps::Vector{Int}) и ранее определенная функция moves!(r,side,num_steps) имеют разные сигнатуры: в первом случае параметр num_steps имеет тип Vector{Int}, а во втором - третий параметр num_steps явно не аннотирован, т.е. фактически его тип - Any. Таким образом, здесь будет действовать множественная диспетчеризация, т.е. на основании этого различия Julia будет знать, какой код должен быть исполнен в том или ином случае.

--------------------------
[<< к началу](#практика-3)

--------------------------
## **Разбор решения задачи 8**
    ДАНО: Робот - рядом с горизонтальной перегородкой (под ней), бесконечно продолжающейся в обе стороны, в которой имеется проход шириной в одну клетку.    
    РЕЗУЛЬТАТ: Робот - в клетке под проходом

### **Первый вариант решения задачи 8**

В этом варианте используются установка маркеров
```julia
function find_passage(r)
    side=Ost
    while isborder(r,Nord)==true # прохода сверху нет
        putmarker!(r)
        move_by_markers!(r,side)
        side=reverse(side)
    end
end

move_by_markers!(r,side) = while ismarker(r) move!(r,side) end

reverse(side::HorizonSide) = HorizonSide(mod(Int(side)+2,4))
```
### **Второй вариант решения задачи 8**

В этом варианте вместо маркеров используется переменная-счетчик числа шагов

```julia
function find_passage(r)
    n=0; side=Ost
    while isborder(r,Nord)==true # прохода сверху нет
        n+=1
        move!(r,side,n)
        side=reverse(side)
    end
end

move!(r,side,num_steps)=for _ in 1:num_steps move!(r,side) end

reverse(side::HorizonSide)=HorizonSide(mod(Int(side)+2,4))
```

--------------------------
[<< к началу](#практика-3)

--------------------------
## **Разбор решения задачи 9**

    ДАНО: Где-то на неограниченном со всех сторон поле и без внутренних перегородок имеется единственный маркер. Робот - в произвольной клетке поля.  
    РЕЗУЛЬТАТ: Робот - в клетке с тем маркером.

```julia
function find_marker(r)
    num_steps_max=1
    side=Nord
    while ismarker(r)==false
        for _ in 1:2
            find_marker(r,side,num_steps_max)
            side=next(side)
        end
        num_steps_max+=1
    end
end

function find_marker(r,side,num_steps_max)
    for _ in 1:num_steps_max
        if ismarker(r)
            return nothing
        end
        move!(r,side)
    end
end

next(side::HorizonSide)=HorizonSide(mod(Int(side)+1,4))
```

--------------------------
[<< к началу](#практика-3)

--------------------------
