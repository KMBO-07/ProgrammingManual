# Лекция 8

- [Лекция 8](#лекция-8)
  - [Замыканя переменной типа Robot в переопределениях стандартных команд Робота](#замыканя-переменной-типа-robot-в-переопределениях-стандартных-команд-робота)
  - [Программирование обобщенных перемещений Робота](#программирование-обобщенных-перемещений-робота)
  - [Модуль FunctionalRobot](#модуль-functionalrobot)
  - [Решение задачи 4 в функциональном стиле](#решение-задачи-4-в-функциональном-стиле)
  - [Задача подсчета числа маркеров на поле в функциональном стиле](#задача-подсчета-числа-маркеров-на-поле-в-функциональном-стиле)

**Функциональный стиль** позволяет программировать в обобщенном виде, т.е. позволяет писать **обобщенные функции**, конкретное поведение котрых будет определяться не столько содержащимся в их определениях кодом (хотя и им тоже, конечно), сколько типами их фактических параметров, в данном случае параметров функционального типа (поскольку речь идет именно о функциональном программировании).

Напомним, что функциональное программирование основывается проектировании на функций высшего порядка, т.е. таких функций, у которых среди аргументов имеются аргументы функционального типа (`<:Function`) и/или, возвращающее значения функционального типа.

Важным также является понятие о "замыкании", т.е. о функции, "замыкающей" свои локальные переменные. Каждая такая функция, если её рассматривать как значение функционального типа, представляет собой одно целое с объектом, содержащим данные (соответствующие её локальным перемеенным). При этом этот объект сохраняется в памяти компьтера и после выполениия функции (замыкания). Таким образом результат выполнения такой функции будет зависеть от текущего состояния соответствующего объекта (которе при каждом новом вызове функции может изменяться).

## Замыканя переменной типа Robot в переопределениях стандартных команд Робота

В предыдущей лекции обсуждалось понятие замыкания функцией перемееной.

В качестве примеров замыкания были приведены переопределения стандартных команд Робота, с целью сделать их более удобными для использования.

А именно, в контексте определенной переменной `robot` могут быть даны следующие более краткие определения командам Робота:

```julia
HorizonSideRobots.isborder(side) = isborder(robot,side)
HorizonSideRobots.ismarker() = ismarker!(robot)
HorizonSideRobots.temperature() = temperature(robot)

HorizonSideRobots.move!(side) = move!(robot,side)
HorizonSideRobots.putmarker!() = putmarker!(robot)
HorizonSideRobots.show!() = show!(robot)
```

Здесь используется механизм множественной диспетчеризации, который в данном случае может быть использован благодаря тому, что каждая из новых функции имеет на единицу меньшее число аргументов, по сравнению с одноименными стандартыми командами Робота.

Все эти вновь определеные функции замыкают переменную robot.

## Программирование обобщенных перемещений Робота

Теперь мы будем писать наш программный код в контексте сделанных выше  определений, которые, подчеркнем еще раз, предполагают, что в текущем пространстве имен была (или будет) доступна переменная `robot`. Это будет делать его менее "зашумленным", и, следовательно, - легче читаемым.

При решении разных задач мы столкнулись с тем, что во многих случаях Робота приходится перемещать практически по одним и темже "траекториям", понимая под "траекторией", например, перемещение "змейкой", или - "по спирали", или "траектория" может напоминать форму гребенки, когда, например, Робот перемещается по горизонтальному ряду, сначала вправо до упора, затем возвращается к началу ряда, а затем перемещается по вертикали в следующий соседний ряд. При этих премещениях Робота в каждой конкретной задаче  обычно делается что-то еще, например, в нужных позициях устанавливаются маркеры, или подсчитывается число имеющихся маркеров и т.д.

Сейчас мы займемся тем, напишем некоторые обобщенные функции, с помощью которых можно будет заставить Робота перемещаться тем имли иным способом, и с помощью введения соответствующих параметров этих обобщенных функций обеспечим возможность их использования для решения широкого спектра конкретных задач. При этом обобщенный подход к программированию избавит от необходимости что-то переделывать в один раз написанном коде при последующем его использовании.

Мы этого добьемся на пути функционального подхода к программированию.

Но, прежде всего, в дополнение к уже написанным функциям, реализующим вызовы стандартных команд Робота, определим в функциональном стиле еще некоторое количество функций, обеспечивающих перемещение Робота по прямой или сявзанных с такими перемещениями. Подобные функции мы уже многократно использовали, но сейчас мы их реализуем еще раз, но уже придерживаясь функционального стиля.

```julia
"""
    movements!(move!::Function, move_condition::Function)

Заставляет Робота делать шаги с помощью функции move (возможно кроме собственно шага, делающей что-то еще), не имеющей аргуменов,
до тех пор, пока логическая функция move_condition (тоже без аргументов) будет возвращать значение true
"""
movements!(move_act!::Function, move_condition::Function) =
while move_condition()
    move_act!()
end

"""
    movements!(move!::Function, num_steps::Integer)

Заставляет Робота делать шаги с помощью функции move (возможно кроме собственно шага, делающей что-то еще), не имеющей аргуменов,
ровно num_steps раз
"""
movements!(move_act!::Function, num_steps::Integer) =
for _ in 1:num_steps
    move_act!()
end


"""
    get_num_movements!(move_condition::Function, side)

-- возвращает число сделанных Роботом шагов в направлении side до тех пор, пока move_condition()==true
"""
function get_num_movements!(move_condition::Function, side)
    num_steps=0
    movements!(()->(move!(side); num_steps+=1), move_condition)
    return num_steps
end
```

Тиеперь, например, мы сможем определить обобщенное перемещение Робота по "змейке", с помощью следующей функции высшего порядка:

```julia
"""
    snake!(move_fold!::Function, fold_direct, general_direct)

-- Осуществляет проход Роботом по рядам "змейкой"
-- Перемещение по каждой "складке змейк" осуществляется с помощью функции move_fold
-- fold_direct, general_direct - направления, определяющие направление перемещения по самой первой "складке" и направление перемещения от "складки" к "складке", соответственно
"""
function snake!(move_fold!::Function, fold_direct, general_direct)
    walk_rows!(
        ()->move_fold!(fold_direct), # - это функция, перемещающая Робота по "складке"

        ()->(                             # - это функция, перемещающая на следующую "складку", если возможно
            fold_direct = inverse(fold_direct);
            if !isborder(general_direct)
                move!(general_direct)
                return true
            else
                return false
            end
        )
    )
end

inverse(side::HorizonSide) = HorizonSide(mod(Int(side)+2, 4))

Функция `snake!` является функцией высшего порядка, потому что она иммеет аргумент функционального типа (`move_fold!`).
Она является обобщенной, потому что ее фактическое поведение зависит от конкретного типа этого ее аргумента (тип аргумента аннотирован абстрактным типом `Fuction`, но каждая конкретная функция будет иметь свой конкретный тип, производный от `Function`).

В определении функции `snake!` использована вспомогательная обобщенная фунция высшего порядка `walk_rows!`. Эта функция предназначена для перемещения Робота по рядам (опять же в обобщенном виде) и предполагает два аргумента функционального типа. Первый - определяет функцию, перемещающую Робота по ряду (по "складке" в данном случае), а второй определяет функцию, выражающую условие продолжения таких перемещений.

Определение самой функции `walk_rows!` приведено ниже (в сответствии с технологией проектирования "сверху вниз").

Важно подчеркнуть, что первый ФАКТИЧЕСКИЙ функциональный аргумент функции `walk_rows!` определен как анонимная функция

```julia
()->move_fold!(fold_direct)
```

которая замыкет локальную переменную `fold_direct` функции `snake!`, а второй ФАКТИЧЕСКИЙ функциональный аргумент функции `walk_rows!` определен как анонимная функция

```julia
()->(                             # - это функция, перемещающая на следующую "складку", если возможно
            fold_direct = inverse(fold_direct)
            if !isborder(general_direct)
                move!(general_direct)
                return true
            else
                return false
            end
```

и эта анонимная функция является замыканем двух локальных переменных `fold_direct` и `general_direct` функции `snake!`.

Примеры использования определенной здесь обобщенной функции высшего порядка `snake!` для решения конкретных задач будут рассмотрены чуть позже.

Теперь опреднлим еще одну обобщенную функцию высшего порядка, с помощью которой можно будет заставить Робота перемещаться по другой траектории (и конечно, выполнять при этом какие-либо другие необходимые действия), а именно, определим обобщенное перемещение Робота по траектории,  форма которй напоминает "гребенку" (по каждому "зубчику" гребенки - туда и обратно, а потом - перемещение на следующий "зубчик").

Для этого напишем с следующую обобщенной функцию высшего порядка:

```julia

"""
    comb!(move_clove!::Function, fold_direct, general_direct)

-- Осуществляет проход Роботом по рядам "расческой"
-- Перемещение по каждому "зубчику расчески" от его начала до конца и обрантно осуществляется с помощью функции move_clove!
-- fold_direct, general_direct - направления, определяющие направление перемещения по самому первому "зубчику" и направление перемещения от "зубчика" к "зубчику", соответственно
"""
function comb!(move_clove!::Function, clove_direct, general_direct)
    walk_rows!(
        ()->move_clove!(clove_direct), # функция, перемещающая Робота по "по зубчику и обратно"

        ()->(
            if !isborder(general_direct)
                move(general_direct)
                return true
            else
                return false
            end
        ) # функция, перемещающая на следующий "зубчик", если возможно
    )
end
```

В обоих примерах программирования обобщенных перемещений, перемешения по "змейке" и по "расческе" использована одна и та же вспомогательная обобщенная функция высшего порядка `walk_rows`.

Вот её определение:

```julia

"""
    walk_rows!(move_row!::Function, nextrow_ifposible!::Function)

 -- перемещает Робота по "соседним" рядам
 -- move_row! - функция без аргументов, перемещающая Робота по одному ряду
 -- nextrow_ifposible! - логическая функция без аргументов, перемещающая Робота в следующий ряд, если это возможно
 (возвращает true, если перемщение состоялось, и false - в противном случае)
"""
function walk_rows!(move_row!::Function, nextrow_ifposible!::Function)
    move_row!()
    while nextrow_ifposible!()
        move_row!()
    end
end
```

Можно было бы определить еще и обобщенное перемещение Робота по "спирали" (например, для решения задачи о поиске маркера на неограниченном поле требовалось перемещать Робота по "спирали"). Но оставим это пока в качестве самостоятельного упражнения.

Далее мы обратимся теперь к конкретным примерам, но прежде нам понадобится определить специальный модуль, в который мы поместим все сделанные выше определения.

## Модуль FunctionalRobot

Для того, чтобы было удобно пользоваться всеми разработанными в предыдущем подразделе универсальными функциями, с использованием функционального стиля,  поместим их определения в специальный модуль, который назовем  `FunctionalRobot`.

Фактически мы создадим на базе модуля некоторую "обертку" исходного Робота, но эта оберка будет не только включать стандартные команды Робота, но и реализовывать расширенный интерфейс, включая все спроектированные выше обобщенные функции (реализующие обобщенные перемещения Робота).

Для этого сам модуль модуль `FunctionalRobot` мы поместим в одноименный файл [`FunctionalRobot.jl`](FunctionalRobot.jl). Причем эот файл удобно будет организовать следующим образом:

```julia
module FunctionalRobot
    export move!, isborder, putmarker!, ismarker, temperature, show!,
            movements!, get_num_movements!,
            snake!, comb!

    include("_functional_robot.jl")
end
```

Здесь собственно тело самого модуля вынесено в отдельный обычный файл (не содержащий конструкции module-end) ["_functional_robot.jl"](_functional_robot.jl).

Так сделано для удобства отладки модуля. Дело в том, что после внесения изменений в модуль простого повторного импортирования этого модуля будет недостаточно  для того, чтобы внесенные изменения вступили в силу - для этого потребовалась бы еще перезапуск REPL. Но если тело модуля хранить в этом обычном файле, то с помощью вызова функции include("_functional_robot.jl") из пространства имен Main, все его содержимое окажется в модуле Main, а при работе непосредственно в Main необходимости в перезапуске REPL возникать не будет.

Существенным моментом является то, что в модуле FunctionalRobot (в файле "_functional_robot.jl") находится глобальная переменная с именем ROBOT (содержаая ссылку на Робота), в контексте которой опредяены все остальные функции модуля. Для инициализации этой глобальной переменной, т.е. для задания начальной обстановки на поле, предусмотрена специальная функция модуля с именем `init`.

Эта функция `init` получает sit-файл с заранее созданной начальной обстановкой, и транслирует её Роботу. При этом режим визуализации при работе с модулем `FunctionalRobot` не предусматривается.
И если потребуется посмотреть изменение обстановки на поле, то для этого следует воспользоваться функцией show!(), также переопределенной в модуле `FunctionalRobot`.

**ПРЕДУПРЕЖДЕНИЕ!!!! Функцию модуля `init`  может быть реализована только при использовании версии 0.3.1+ пакета HorizonSideRobots. Поэтому необходимо выполнить соответствующее обновление пакета (заново установить его с github), если это еще не сделано.**

ОЧЕНЬ ВАЖНОЕ ЗАМЕЧАНИЕ.

Еще раз обратим внимание на то, как следует и как не следует использовать глобальные переменные.
Глобальные переменные не должны использоваться как ни попадя. Решение использовать глобальную переменную всегда должно быть тщательно продуманым, потому что наличие глобальных переменны приводит к контекстно зависимому коду, вдобавок часто трудно понимаемому и трудно отлаживаемому.

Иногда глобальные переменные могут использоваться как временное решение, что бы быстро и с минимальными переделками внести в программу необходимые изменения (а потом избавиться от введенных для этого глобальных переменных).

Такими образцовыми примерами следует считать примеры из [лекции 6](../6/Лекция-6.md), пример модуля `Decart`, разработанный в [практике 7](../7/Практика-7.md), а также разработанный здесь модуль `FunctionalRobot`

За пределами этих образцов начинающим программистам настоятельно рекомендуется **вообще не использовать глобальные переменные**.

## Решение задачи 4 в функциональном стиле

```julia
    ДАНО: Робот - Робот - в произвольной клетке ограниченного прямоугольного поля

    РЕЗУЛЬТАТ: Робот - в исходном положении, и клетки поля промакированы так:
        нижний ряд - полностью,
        следующий - весь, за исключением одной последней клетки на Востоке,
        следующий - за исключением двух последних клеток на Востоке,
        и т.д.
```

Соответствующий программный код содержится в [файле "example_1.jl"](example_1.jl).

Чтобы исполнить содержащийся в этом файле код достаточно будет просто вставить этот файл в REPL:

```julia
julia> include("example_1.jl")
```

## Задача подсчета числа маркеров на поле в функциональном стиле

Пусть Робот находится у западной границы некоторого ряда, внутренних перегородок на поле нет, тебуется посчитать число всех маркеров в ряду.

Решение этой задачи в функциональном стиле было рассмотрено на прошлой лекции.

Но теперь, когда у нас есть модуль `FunctionalRobot`, мы могли бы воспользоватся этим модулем. Соответсвующий программный код находится в [файле "example_2.jl"](example_2.jl).

Чтобы исполнить содержащийся в этом файле код достаточно будет просто вставить этот файл в REPL:

```julia
julia> include("example_2.jl")
```

А вот если бы cзадача стояла так, что изначально Робот находился в юго-западном углу поля, и требуется подсчитать число всех маркеров на поле, то соответсвующий программный код, помещенный в [файл "example_3.jl"](example_3.jl),быдет выглядеть похожим образом.

И чтобы исполнить содержащийся в этом файле код опять достаточно будет просто вставить этот файл в REPL:

```julia
julia> include("example_3.jl")
```

Создать нужную начальную обстановку на поле, в том числе предварительно разместить на нем некоторое количество маркеров, если мы хотим пользоваться модулем `FunctionalRobot`, можно лишь с помощью специально предусмотренной для этого функции модуля `init`.
 
Для этого сначала нужно с помощью функции `sitcreate` создать sit-файл с требуемой обстановкой, а затем выполнить функцию `init`, передав ей через параметр имя созданного файла. Тогда модуль `FuncnionalRobot` будет работать в условиях этой обстановки.

Использование модуля `FuncnionalRobot` в режиме анимации сейчас не предусмотрено, однако, если в этом модуле строку

```julia
ROBOT = Robot()
```

заменить на

```julia
ROBOT = Robot(animate=true)
```

то модуль будет работать в режиме анимации (но устанавливать начальную обстановку всё-равно пришлось бы с помощью функции `init`, так, как это было описано выше).