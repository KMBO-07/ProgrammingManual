# Лекция 8

- [Лекция 8](#лекция-8)
  - [Замыканя переменной типа Robot в переопределениях стандартных команд Робота](#замыканя-переменной-типа-robot-в-переопределениях-стандартных-команд-робота)
  - [Программирование обобщенных перемещений Робота](#программирование-обобщенных-перемещений-робота)
  - [Модуль FunctionalRobot](#модуль-functionalrobot)
  - [Решение задачи 4 в функциональном стиле](#решение-задачи-4-в-функциональном-стиле)
  - [Задача подсчета числа маркеров на поле в функциональном стиле](#задача-подсчета-числа-маркеров-на-поле-в-функциональном-стиле)

**Функциональный стиль** позволяет программировать в обобщенном виде, т.е. позволяет писать **обобщенные функции**, конкретное поведение котрых будет определяться не столько содержащимся в их определениях кодом (хотя и им тоже, конечно), сколько типами их фактических параметров, в данном случае параметров функционального типа (поскольку речь идет именно о функциональном программировании).

Напомним, что функциональное программирование основывается на использовании и проектировании функций высшего порядка, т.е. таких функций, у которых или среди аргументов имеются аргументы функционального типа (`<:Function`), и/или, возвращаемые ими значения  имеют функциональный тип.

При этом функции рассматриваются как объекты, равноправные с обычными объектами, т.е. в этом смысле являются объектами "первого класса". Это означает также, что функция может быть анонимной, т.е. представлять собой просто функциональное значение как таковое, без имени. Подобно тому, как может быть без имени, скажем, числовое значение, т.е. значение, не ассоцированное с переменной, а используемое непосредственно.

Важным также является понятие о "замыкании", т.е. о функции, "замыкающей" свои локальные переменные. Каждая такая функция, если её рассматривать как значение функционального типа, представляет собой одно целое с объектом, содержащим данные (соответствующие её локальным перемеенным). При этом этот объект сохраняется в памяти компьтера и после выполениия функции (замыкания). Таким образом результат выполнения такой функции будет зависеть от текущего состояния соответствующего объекта (которе при каждом новом вызове функции может изменяться).

## Замыканя переменной типа Robot в переопределениях стандартных команд Робота

В предыдущей лекции обсуждалось понятие замыкания функцией перемееной.

В качестве примеров замыкания были приведены переопределения стандартных команд Робота, с целью сделать их более удобными для использования.

А именно, в контексте определенной переменной `robot` могут быть даны следующие более краткие определения командам Робота:

```julia
HorizonSideRobots.isborder(side) = isborder(robot,side)
HorizonSideRobots.ismarker() = ismarker!(robot)
HorizonSideRobots.temperature() = temperature(robot)

HorizonSideRobots.move!(side) = move!(robot,side)
HorizonSideRobots.putmarker!() = putmarker!(robot)
HorizonSideRobots.show!() = show!(robot)
```

Здесь используется механизм множественной диспетчеризации, который в данном случае может быть использован благодаря тому, что каждая из новых функции имеет на единицу меньшее число аргументов, по сравнению с одноименными стандартыми командами Робота.

Все эти вновь определеные функции замыкают переменную robot.

## Программирование обобщенных перемещений Робота

Теперь мы будем писать наш программный код в контексте сделанных выше  определений, которые, подчеркнем еще раз, предполагают, что в текущем пространстве имен была (или будет) доступна переменная `robot`. Это будет делать его менее "зашумленным", и, следовательно, - легче читаемым.

При решении разных задач мы столкнулись с тем, что во многих случаях Робота приходится перемещать практически по одним и темже "траекториям", понимая под "траекторией", например, перемещение "змейкой", или - "по спирали", или "траектория" может напоминать форму гребенки, когда, например, Робот перемещается по горизонтальному ряду, сначала вправо до упора, затем возвращается к началу ряда, а затем перемещается по вертикали в следующий соседний ряд. При этих премещениях Робота в каждой конкретной задаче  обычно делается что-то еще, например, в нужных позициях устанавливаются маркеры, или подсчитывается число имеющихся маркеров и т.д.

Сейчас мы займемся тем, напишем некоторые обобщенные функции, с помощью которых можно будет заставить Робота перемещаться тем имли иным способом, и с помощью введения соответствующих параметров этих обобщенных функций обеспечим возможность их использования для решения широкого спектра конкретных задач. При этом обобщенный подход к программированию избавит от необходимости что-то переделывать в один раз написанном коде при последующем его использовании.

Мы этого добьемся на пути функционального подхода к программированию.

Но, прежде всего, в дополнение к уже написанным функциям, реализующим вызовы стандартных команд Робота, определим в функциональном стиле еще некоторое количество функций, обеспечивающих перемещение Робота по прямой или сявзанных с такими перемещениями. Подобные функции мы уже многократно использовали, но сейчас мы их реализуем еще раз, но уже придерживаясь функционального стиля.

```julia
"""
    movements!(move_act!::Function, move_condition::Function)

Заставляет Робота делать шаги с помощью функции move_act!() 
до тех пор, пока логическая функция move_condition() не вернет false
"""
movements!(move_act!::Function, move_condition::Function) =
while move_condition()
    move_act!()
end

"""
    movements!(move_act!::Function, num_steps::Integer)

Заставляет Робота делать шаги с помощью функции move_act!() ровно num_steps раз
"""
movements!(move_act!::Function, num_steps::Integer) =
for _ in 1:num_steps
    move_act!()
end


"""
    get_num_movements!(move_condition::Function, side)

Возвращает число сделанных Роботом шагов в направлении side до тех пор, пока move_condition()==true
-- move_condition() - логическая функция, определяющая заданное условие      
"""
function get_num_movements!(move_condition::Function, side)
    num_steps=0
    movements!(()->(move!(side); num_steps+=1), move_condition)
    return num_steps
end
```

Тиеперь, например, мы сможем определить обобщенное перемещение Робота по "змейке", с помощью следующей функции высшего порядка:

```julia
"""
    snake!(move_fold!::Function, fold_direct::HorizonSide, general_direct::HorizonSide)

Осуществляет проход Робота по рядам "змейкой" (в местах разворота возможны самоналожения траектории, и последняя складка может получиться полностью наложена на предыдущую)
-- move_fold!(::HorizonSide) - функция, перемещающая Робота по очередной "складке змейки", и возвращающая логическое значение:
если возвращает false, то  - это сигнал, чтобы движение "змейкой" было остановлено
-- fold_direct - направление перемещения по (самой первой) "складке" 
-- general_direct - направление перемещения от "складки" к "складке"
"""
function snake!(move_fold!::Function, fold_direct::HorizonSide, general_direct::HorizonSide)
    function to_next_fold!(general_direct)                            # - функция, перемещающая на следующую "складку", если это возможно
        prew_direct = fold_direct
        fold_direct = inverse(fold_direct) # - внешняя переменная
        while isborder(general_direct)
            if !isborder(fold_direct)
                move!(fold_direct)
            else
                return false # прохода в направлении general_direct нигде нет
            end
        end
        #УТВ: в направлении general_direct нет перегородки
        move!(general_direct)
        movements!(()->move!(prew_direct), ()->!isborder(prew_direct))
        return true
    end

    if move_fold!(fold_direct)==false return end 
    while to_next_fold!(general_direct)==true && move_fold!(fold_direct)==true end
end

inverse(side::HorizonSide) = HorizonSide(mod(Int(side)+2, 4))

Функция `snake!` является функцией высшего порядка, потому что она иммеет аргумент функционального типа (`move_fold!`).
Она является обобщенной, потому что ее фактическое поведение зависит от конкретного типа этого ее аргумента (тип аргумента аннотирован абстрактным типом `Fuction`, но каждая конкретная функция будет иметь свой конкретный тип, производный от `Function`).

Примеры использования определенной здесь обобщенной функции высшего порядка `snake!` для решения конкретных задач будут рассмотрены чуть позже.

Теперь опреднлим еще одну обобщенную функцию высшего порядка, с помощью которой можно будет заставить Робота перемещаться по другой траектории (и конечно, выполнять при этом какие-либо другие необходимые действия), а именно, определим обобщенное перемещение Робота по траектории,  форма которй напоминает "гребенку" (по каждому "зубчику" гребенки - туда и обратно, а потом - перемещение на следующий "зубчик").

Для этого напишем с следующую обобщенной функцию высшего порядка:

```julia

"""
    comb!(there_and_back!::Function, clove_direct::HorizonSide, general_direct::HorizonSide)

-- Осуществляет проход Роботом по рядам "гребенкой"
-- there_and_back!(::HorizonSide) - функция, перемещающая Робота по очередному "зубчику гребёнки", от его начала до конца и обрантно, и 
возвращающая логическое значение: если возвращает false, то  - это сигнал, чтобы движение "гребенкой" было остановлено
-- clove_direct - направления, определяющие направление перемещения по самому первому "зубчику"
-- general_direct - направление перемещения от "зубчика" к "зубчику"
"""
function comb!(there_and_back!::Function, clove_direct::HorizonSide, general_direct::HorizonSide)
    function to_next_clove(general_direct)
        if !isborder(general_direct)
            move!(general_direct)
            return true
        else
            return false
        end
    end

    there_and_back!(clove_direct)
    while to_next_clove(general_direct) && there_and_back!(clove_direct) end
end
```

Можно было бы определить еще и обобщенное перемещение Робота по "спирали" (например, для решения задачи о поиске маркера на неограниченном поле требовалось перемещать Робота по "спирали"). Но оставим это пока в качестве упражнения.

Обратимся теперь к конкретным примерам, но прежде нам понадобится определить специальный модуль, в который мы поместим все сделанные выше определения.

## Модуль FunctionalRobot

Для того, чтобы было удобно пользоваться всеми разработанными в предыдущем подразделе универсальными функциями, с использованием функционального стиля,  поместим их определения в специальный модуль, который назовем  `FunctionalRobot`.

Фактически мы создадим на базе модуля некоторую "обертку" исходного Робота, но эта оберка будет не только включать стандартные команды Робота, но и реализовывать расширенный интерфейс, включая все спроектированные выше обобщенные функции (реализующие обобщенные перемещения Робота).

Для этого сам модуль модуль `FunctionalRobot` мы поместим в одноименный файл [`FunctionalRobot.jl`](FunctionalRobot.jl). Причем эот файл удобно будет организовать следующим образом:

```julia
module FunctionalRobot
    export move!, isborder, putmarker!, ismarker, temperature, show!,
            movements!, get_num_movements!,
            snake!, comb!

    include("_functional_robot.jl")
end
```

Здесь собственно тело самого модуля вынесено в отдельный обычный файл (не содержащий конструкции module-end) ["_functional_robot.jl"](_functional_robot.jl).

Так сделано для удобства отладки модуля. Дело в том, что после внесения изменений в модуль простого повторного импортирования этого модуля будет недостаточно  для того, чтобы внесенные изменения вступили в силу - для этого потребовалась бы еще перезапуск REPL. Но если тело модуля хранить в этом обычном файле, то с помощью вызова функции include("_functional_robot.jl") из пространства имен Main, все его содержимое окажется в модуле Main, а при работе непосредственно в Main необходимости в перезапуске REPL возникать не будет.

Существенным моментом является то, что в модуле FunctionalRobot (в файле "_functional_robot.jl") находится глобальная переменная с именем ROBOT (содержаая ссылку на Робота), в контексте которой опредяены все остальные функции модуля. Для инициализации этой глобальной переменной, т.е. для задания начальной обстановки на поле, предусмотрена специальная функция модуля с именем `init`.

Эта функция `init` получает sit-файл с заранее созданной начальной обстановкой, и транслирует её Роботу. При этом режим визуализации при работе с модулем `FunctionalRobot` не предусматривается.
И если потребуется посмотреть изменение обстановки на поле, то для этого следует воспользоваться функцией show!(), также переопределенной в модуле `FunctionalRobot`.

**ПРЕДУПРЕЖДЕНИЕ!!!! Функцию модуля `init`  может быть реализована только при использовании версии 0.3.1+ пакета HorizonSideRobots. Поэтому необходимо выполнить соответствующее обновление пакета (заново установить его с github), если это еще не сделано.**

ОЧЕНЬ ВАЖНОЕ ЗАМЕЧАНИЕ.

Еще раз обратим внимание на то, как следует и как не следует использовать глобальные переменные.
Глобальные переменные не должны использоваться как ни попадя. Решение использовать глобальную переменную всегда должно быть тщательно продуманым, потому что наличие глобальных переменны приводит к контекстно зависимому коду, вдобавок часто трудно понимаемому и трудно отлаживаемому.

Иногда глобальные переменные могут использоваться как временное решение, что бы быстро и с минимальными переделками внести в программу необходимые изменения (а потом избавиться от введенных для этого глобальных переменных).

Такими образцовыми примерами следует считать примеры из [лекции 6](../6/Лекция-6.md), пример модуля `Decart`, разработанный в [практике 7](../7/Практика-7.md), а также разработанный здесь модуль `FunctionalRobot`

За пределами этих образцов начинающим программистам настоятельно рекомендуется **вообще не использовать глобальные переменные**.

## Решение задачи 4 в функциональном стиле

```julia
    ДАНО: Робот - Робот - в произвольной клетке ограниченного прямоугольного поля

    РЕЗУЛЬТАТ: Робот - в исходном положении, и клетки поля промакированы так:
        нижний ряд - полностью,
        следующий - весь, за исключением одной последней клетки на Востоке,
        следующий - за исключением двух последних клеток на Востоке,
        и т.д.
```

Соответствующий программный код содержится в [файле "example_1.jl"](example_1.jl).

Чтобы исполнить содержащийся в этом файле код достаточно будет просто вставить этот файл в REPL:

```julia
julia> include("example_1.jl")
```

## Задача подсчета числа маркеров на поле в функциональном стиле

Пусть Робот находится у западной границы некоторого ряда, внутренних перегородок на поле нет, тебуется посчитать число всех маркеров в ряду.

Решение этой задачи в функциональном стиле было рассмотрено на прошлой лекции.

Но теперь, когда у нас есть модуль `FunctionalRobot`, мы могли бы воспользоватся этим модулем. Соответсвующий программный код находится в [файле "example_2.jl"](example_2.jl).

Чтобы исполнить содержащийся в этом файле код достаточно будет просто вставить этот файл в REPL:

```julia
julia> include("example_2.jl")
```

А вот если бы cзадача стояла так, что изначально Робот находился в юго-западном углу поля, и требуется подсчитать число всех маркеров на поле, то соответсвующий программный код, помещенный в [файл "example_3.jl"](example_3.jl),быдет выглядеть похожим образом.

И чтобы исполнить содержащийся в этом файле код опять достаточно будет просто вставить этот файл в REPL:

```julia
julia> include("example_3.jl")
```

Создать нужную начальную обстановку на поле, в том числе предварительно разместить на нем некоторое количество маркеров, если мы хотим пользоваться модулем `FunctionalRobot`, можно лишь с помощью специально предусмотренной для этого функции модуля `init`.
 
Для этого сначала нужно с помощью функции `sitcreate` создать sit-файл с требуемой обстановкой, а затем выполнить функцию `init`, передав ей через параметр имя созданного файла. Тогда модуль `FuncnionalRobot` будет работать в условиях этой обстановки.

Использование модуля `FuncnionalRobot` в режиме анимации сейчас не предусмотрено, однако, если в этом модуле строку

```julia
ROBOT = Robot()
```

заменить на

```julia
ROBOT = Robot(animate=true)
```

то модуль будет работать в режиме анимации (но устанавливать начальную обстановку всё-равно пришлось бы с помощью функции `init`, так, как это было описано выше).