# Лекция 8

- [Лекция 8](#лекция-8)
  - [Именованные кортежи](#именованные-кортежи)
  - [Проектирование функций высшего порядка, возвращающих интерфейсы](#проектирование-функций-высшего-порядка-возвращающих-интерфейсы)
  - [Программирование обобщенных прямолинейных перемещений Робота](#программирование-обобщенных-прямолинейных-перемещений-робота)
  - [Программирование обобщенных перемещений Робота по специальным траекториям](#программирование-обобщенных-перемещений-робота-по-специальным-траекториям)

**Функциональный стиль** позволяет программировать в обобщенно, т.е. позволяет писать **обобщенные функции**.

Вообще, обобщённые функции отличаются тем, что они определяются с использованием формальных параметров абстрактных типов, а соответствующием им фактические аргументы конкретных типов определяют уже поведение таких функций.

В случае функционального стиля программирования мы имеем дело с функциями высшего порядка с формальными параметрами типа Function, который является абстрактным типом.

Напомним, что функциональное программирование основывается на использовании и проектировании функций высшего порядка, т.е. таких функций, у которых или среди аргументов имеются аргументы функционального типа (`<:Function`), и/или, возвращаемые ими значения  имеют функциональный тип.

При этом в языках программирования, поддерживающих функциональный стиль, функции рассматриваются как объекты, равноправные с обычными объектами, т.е. в этом смысле являются объектами "первого класса". Это означает также, что функция может быть анонимной, т.е. представлять собой просто функциональное значение как таковое, без имени. Подобно тому, как может быть без имени, скажем, числовое значение, т.е. значение, не ассоцированное с переменной, а используемое непосредственно.

Важным для функционального стиля программирования является также понятие о "замыкании", т.е. о функции, "замыкающей" какие-либо внешние по отношению к ней переменные. Каждая такая функция, если её рассматривать как значение функционального типа, представляет собой одно целое с объектом (замыкаемыми ею внешними переменными). При этом этот объект сохраняется в памяти компьтера и после выполениия функции (замыкания). Таким образом результат выполнения замыкания зависит от текущего состояния замыкаемых переменных (объекта).

## Именованные кортежи

Прежде чем мы сможем продолжить обсуждение функционального стиля программирования, в частности - рассмотреть примеры функций высшего порядка, возвращающих интерфейсы, нам потребуется разобраться с ещё одним встоеннным типом данных, с так называемыми именованными кортежами (`NamedTuple`).

Во-первых, вспомним ещё раз, что такое обычные кортежи (Tuple). Например

```julia
julia> a=(1,2,3)
```

Это кортеж из 3-х элементов, каждый из котрых имеет тип Int64. Вообще элементы кортежа могут иметь любой тип, и типы разных элементов одного кортежа не обязательно должны совпадать.

Элементы кортежа индексируются также как и элементы массива:

```julia
julia> a[2]
2
```

Но в отличии от массива элементы кортежа не изменяемы:

```julia
julia> a[2]=0
ERROR: MethodError: no method matching setindex!(::Tuple{Int64,Int64,Int64}, ::Int64, ::Int64)
```

Теперь про имерованные кортежи. Рассмотрим сразу пример:

```julia
julia> a=(x=10,y=20)
julia> a[1]
10
julia> a.x
10
julia> a[:x]
10
```

Попутно заметим, что значение `:x` имеет `Synbol`, и вообще, любая последовательность символов, начинающаяся с `:` представляет собой значение типа `Symbol`.

В частности значениями элементов кортежа могут быть функции:

```julia
julia> a=(f=sin,g=(x->x^2))
julia> a[1](π/2)
1.0
julia> a.f(π/2)
1.0
julia> a.g(2)
4
```

Иметнованный кортеж является итерируемым объектом, т.е. может именованный кортеж быть использова в цикле `for`:

```julia
for a in (x=1,y=2,z=3)
    println(a)
end
1
2
3
```

Именованный кортеж может быть преобразован в обычный кортеж или в массив:

```julia
julia> Tuple((x=1,y=2,z=3))
(1,2,3)

julia> collect((x=1,y=2,z=3))
3-element Array{Int64,1}:
 1
 2
 3
```

Кортежи, как обычные, так и именованные, могут состоять и только из одного элемента:

```julia
julia> (1,)
(1,)

julia> typeof((1,))
Tuple{Int64}
```

Но если "," после единственного элемента кортежа не поставить, то кортежа не получится:

```julia> (1)
1

julia> typeof((1))
Int64
```

Вообще запятая после последнего элемента кортежа допустима всегда

```julia
julia> (1,2,3,)
(1,2,3)
```

Всё то же относится и к именованным кортежам.

ЗАМЕЧАНИЕ. Запись вида

```julia
(x=1; y=2)
```

кортежем не является, это есть просто последовательность операторов (программный блок). Эта запись равнозначно записи

```julia
begin x=1; y=2 end
```

Программные блоки также можно записывать так

```julia
(
    x=1
    y=2
)
```

или, соответственно, так

```julia
begin
    x=1
    y=2
end
```

Начиная с версии 1.5 в языке Julia действует следующее соглашение:
Если в текущем контексте определены какие-то две переменные, например,

```julia
x = 1
y = 2
```

то

```juila
named_tuple = (;x,y)
```

эквивалентно

```julia
named_tuple = (x=x,y=y)
```

Это, на самом деле, очень удобно, в чем мы скоро убедимся.

Соединить два кортежа в один можно, например, воспльзовавшись операцией "распаковки", записываемой с помощью "...":

```julia
x = (a=1,b=2)
y = (c=3,d=4,e=5)

z=(x...,y...)
```

Аналогичным образом можно "добавить" (на спмом деле - создать новый картеж) в кортеж еще один элемент:

```julia
x=(1,2,3)
y=(x..., 4)
```

(то же самое относится и к именованным кортежам).

## Проектирование функций высшего порядка, возвращающих интерфейсы

В предыдущей лекции обсуждалось понятие замыкания функцией переменной. В частоности выло рассмотрено следующее переопределение стандартных команд Робота, замыкающих переменную типа Robot

```julia
using HorizonSideRobots

interface_robot(robot) = (
    side->HorizonSideRobots.move!(robot,side),
    side->HorizonSideRobots.isborder(robot,side),
    ()->HorizonSideRobots.putmarker!(robot),
    ()->HorizonSideRobots.ismarker(robot),
    ()->HorizonSideRobots.temperature(robot)
)

robot=Robot()
move!, isborder, putmarker!, ismarker, temperature = interface_robot(robot)
```

После этого можно было бы командовть Роботом, например, так:

```julia
move!(Nord), isborder(Nord), putmarker!(), ismarker(), temperature()
```

Что выглядит более кратко.

Однако у этого решения есть недостаток, состоящий в том, что имена этих команд Робота определяются при получении их из функции высшего порядка `interface_robot`, т.е. ответственность за выбор имен этих команд здесь возлагается на пользователя функции `interface_robot`. Но тогда получается, что невозможно использовать интерфейс, возвращаемый функцией `interface_robot` для разработки универсальных вспомогательных функций, потому что предполагаемому разработчику таких функций имена  `move!(Nord), isborder(Nord), putmarker!(), ismarker(), temperature()`, заранее не известны, они будут определены уже когда-то и кем-то потом.

Выход из такого положения состоит в том, что вместо обычного кортежа, возвращаемого функцией `interface_robot`, использовать так называемый именованный кортеж. А именно, функцию `interface_protected_robot` следовало бы определить так

```julia
interface_protected_robot(robot) = (
  move! = (if isborder(robot,side) false else move!(robot,side); true end),
  isborder = side->HorizonSideRobots.isborder(robot,side),
  putmarker! = ()->HorizonSideRobots.putmarker!(robot),
  ismsrker = ()->HorizonSideRobots.ismarker(robot),
  temperature = ()->HorizonSideRobots.temperature(robot)
)
```

Заодно здесь мы немного усовершенствовали первоначальную функцию `move!(side)`, теперь, если рядом с Роботом в направлении `side` находится перегородка, то при попытке сделать шаг в этом направлении Робот не врежется в перегородку и не произойдет фатальное прерывание вычислительного процесса, а Робот просто не сдвинется с места, но будет возвращено значение `false`, в противном случае возвращается - `true`.

Такая функция оказывается более удобной (например, для реализации функции высшего порядка `interface_line` в следующем разделе). При этом, поскольку теперь функцией `move!` можно пользоваться без опасений врезаться в перегородку, соответствующий командный интерфейс будем называть защищенным (`protected`).

Тогда пользоваться этой функцией надо будет так

```julia
robot=Robot()
robot = interface_protected_robot(robot)
```

После последнего присваивания переменная `robot` содержит уже не ссылку на объект типа Robot, а именованный кортеж, содержащий командный интерфейс соответствующего исполнителя.

В результате командовть Роботом теперь надо будет уже так:

```julia
robot.move!(Nord), robot.isborder(Nord), robot.putmarker!(), robot.ismarker(), robot.temperature()
```

Можно было бы, конечно, еще и так:

```julia
robot[1](Nord), robot[2](Nord), robot[3](), robot[4](), robot[5]()
```

соответственно, но так делать, разумеется, не стоит.

## Программирование обобщенных прямолинейных перемещений Робота

Стандартная команда Робота `move` позволяет переместить Робота в соседнюю клетку в заданном направлении.
Однако чсасто приходится перемещать Робота в заданном направлении или до упора, или - в заданном направлении на некоторое заданное количество шагов. Часто приходится также перемещать Робота в заданном направлении до упора и возвращать число сделанных им при этом шагов.

Вот как это будет выглядеть в функциональном стиле и с использованием нового командного интерфейса (см. выше)

```julia
"""
interface_line(move!::Function)

    Получает "защищённую" функцию move!(side)::Bool, выполняющую перемещение Робота в ближайшую доступную клетку в направлении side и возвращающую true, 
    если доступная клетка существует, и оставляющую Робота на месте и возвращающую false - в противном случае

возвращает кортеж функций:

    movements!(side) - перемещает Робота "до упора" в заданном направлении
    movements!(side, num_steps::Integer) - перемещает Робота в заданном направлении на заданное число шагов
    movements!(action!::Function, side) - перемещает Робота "до упора" в заданном направлении
    movements!(action!::Function, side, num_steps::Integer) - перемещает Робота в заданном направлении на заданное число шагов

    get_num_movements!(side) - перемещает Робота "до упора" в заданном направлении и возвращает число сделанных шагов
    get_num_movements!(action!::Function, side) - перемещает Робота "до упора" в заданном направлении и возвращает число сделанных шагов

    при этом в соответствующих случаях здесь после каждого шага выполняется action!()

"""
interface_line(move!::Function) = begin
    movements!(side) = while move!(side)==true end
    movements!(side, num_steps::Integer) = for _ in 1:num_steps move!(side) end
    movements!(action::Function, side) = while move!(side)==true action() end
    movements!(action!::Function, side, num_steps::Integer) = for _ in 1:num_steps move!(side); action!() end

    function get_num_movements!(side)
        num_steps=0
        while move!(side)==true
            num_steps+=1
        end
        return num_steps
    end

    function get_num_movements!(action::Function, side)
        num_steps=0
        while move!(side)==true
            action()
            num_steps+=1
        end
        return num_steps
    end

    return (;movements!, get_num_movements!)
end # interface_line-----------------------------------------------
```

Здесь, в записи `(; movements!, get_num_movements!)`, было испльзовано отмеченное выше соглашение относительно формирования именованных кортежей, которая эквивалентна
`(movements! = movements!, get_num_movements! = get_num_movements!)`.

Теперь, чтобы переместить Робота, например, до упора на восток, можно будет сделать так:

```julia
robot=Robot()
line = interface_line((side)->move!(robot,side))
line.movements!(Ost)
```

## Программирование обобщенных перемещений Робота по специальным траекториям

При решении разнообразных задач мы уже столкивались с тем, что во многих случаях Робота приходится перемещать не только прямолинейно, но и, например, "змейкой", или "по спирали", или, быть может траектория движения Робота должна напоминать форму гребенки. Причем такого рода траектории перемещения Робота следует считать базовыми, поскольку на них основываны решения множества задач.

Раньше нам приходилось в каждой конкретной задаче каждый раз заново программировать такого рода перемещения. Но теперь мы постараемся написать соответствующие обобщенные функции, которые затем могут быть использованы при решении множества разнообразных задач и при этом в их код не придется каждый раз вносить каких-либо изменений. Т.е. будет соблюдаться принцип обобщенного программирования: один раз написанные обобщенные функции будут выполнять те или иные конкретные действия в зависимости от фактических типов их аргументов. В данном случае для этого будут предусмотрены аргументы абстрактного типа `Function`, т.е. планируемые обобщенные функции будут функциями высшего порядка.

Для реализации задуманного мы спроектируем функцию высшего порядка `interface_trajectories(robot)`, возвращающую интерфейс, содержащий требуемые обобщенные функции, перемещающие Робота по специальным траекториям.

Вот как это будет выглядеть

```julia
"""
interface_trajectories(robot)

-- robot - именованный кортеж, содержащий интерфейс Робота, включающий функции
    move!, isborder
-- Возвращает интерфейс, содержащий функции:

snake!(move_fold!::Function, fold_direct::HorizonSide, general_direct::HorizonSide)

    Осуществляет проход Робота по рядам "змейкой" (в местах разворота возможны самоналожения траектории, и последняя складка может получиться полностью наложена на предыдущую)
    -- move_fold!(::HorizonSide) - функция, перемещающая Робота по очередной "складке змейки", и возвращающая логическое значение:
    если возвращает false, то  - это сигнал, чтобы движение "змейкой" было остановлено
    -- fold_direct - направление перемещения по (самой первой) "складке" 
    -- general_direct - направление перемещения от "складки" к "складке"

labirint_snake!(move_fold!::Function, fold_direct::HorizonSide, general_direct::HorizonSide)

    Осуществляет проход Робота по рядам простого лабиринта "змейкой". 
    Под простым лабиринтом понимается лабиринт который пересекается горизонтальными пярмыми ровно два раза. 
    При этом в местах разворота возможны самоналожения траектории (последняя складка будет получиться полностью наложеннной на предыдущую),
    но функция move_fold! отвечает только за одноразовый проход по складке (самоналожения могут возникать только при попытках перемещения на новую склажку).
    -- move_fold!(::HorizonSide) - функция, перемещающая Робота по очередной "складке змейки", и, ВОЗМОЖНО, возвращающая логическое значение:
    если возвращает false, то  - это сигнал, чтобы движение "змейкой" было остановлено 
    (в принципе, move_fold!(...) может возвращать и любое другое значение, не обязательно типа Bool, например - nothing, 
    но тогда "змейка" будет пройдена до самого конца)
    -- fold_direct - направление перемещения по (самой первой) "складке" 
    -- general_direct - направление перемещения от "складки" к "складке"

comb!(there_and_back!::Function, clove_direct::HorizonSide, general_direct::HorizonSide)

    -- Осуществляет проход Роботом по рядам "гребенкой"
    -- there_and_back!(::HorizonSide) - функция, перемещающая Робота по очередному "зубчику гребёнки", от его начала до конца и обрантно, и 
    возвращающая логическое значение: если возвращает false, то  - это сигнал, чтобы движение "гребенкой" было остановлено
    -- clove_direct - направления, определяющие направление перемещения по самому первому "зубчику"
    -- general_direct - направление перемещения от "зубчика" к "зубчику"

spiral!(move_act!::Function)

    Перемещает Робота по раскручивающейся в положительном направлении спирали (первый шаг - на север) до момента наступления 
    некотрого события, определяемого функцией move_act!(::HorizonSide)
    -- move_act!(::HorizonSide)::Bool - функция перемещающая Робота в заданном направлении на 1 шаг (и, возможно, делающая что-то еще), и
    возвращая логическое значение: если возвращается false, то - это сигнал, чтобы движение "змейкой" было остановлено.
"""
function interface_trajectories(robot)

  function snake!(move_fold!::Function, fold_direct::HorizonSide, general_direct::HorizonSide)
    if move_fold!(fold_direct)==false
      return
    end
    while !robot.isborder(general_direct)
      robot.move!(general_direct)
      fold_direct = inverse(fold_direct)
      if move_fold!(fold_direct)==false
        return
      end
    end
  end # function snake!

  function labirint_snake!(move_fold!::Function, fold_direct::HorizonSide, general_direct::HorizonSide)

    function to_next_fold!(general_direct)::Bool 
      # перемещающает Робота в начало следующей "складки", если это возможно
      prew_direct = fold_direct
      fold_direct = inverse(fold_direct) # - внешняя переменная
      while robot.isborder(general_direct)
        if !robot.isborder(fold_direct)
          robot.move!(fold_direct)
        else
          return false # прохода в направлении general_direct нигде нет
        end
      end
      #УТВ: в направлении general_direct нет перегородки
      robot.move!(general_direct) #!!!
      while !robot.isborder(prew_direct)
        robot.move!(prew_direct)
      end
      return true
    end # nested function to_next_fold!

    if move_fold!(fold_direct)==false
      return
    end
    while to_next_fold!(general_direct)==true
      if move_fold!(fold_direct)==false
        return
      end
    end
  end # function labirint_snake!

  function spiral!(move_act!::Function)

    function next_round!(side, max_num_steps::Integer) # - на очереном витке увеличивает длину сегмента спирали
      if side in (Sud, Nord)
        max_num_steps+=1
      end
      return max_num_steps
    end # nested function next_round!

    function move_direct!(move_act!::Function, side, max_num_steps::Integer)
    # перемещает Робота в заданном направлении не более чем на max_num_steps шагов с помощью функции move_act!(side)
      num_steps=0
      while (num_steps <= max_num_steps)
        if move_act!(side) == false
          return false
        end
        num_steps+=1
      end
      return true
    end # nested function move_direct!

    side = Nord
    max_num_steps = 1
    while move_direct!(move_act!, side, max_num_steps) == true
      max_num_steps = next_round!(side, max_num_steps)
      side=left(side)
    end
  end # function spiral!

  function comb!(there_and_back!::Function, clove_direct::HorizonSide, general_direct::HorizonSide)

    function to_next_clove!(general_direct)
      if !robot.isborder(general_direct)
        robot.move!(general_direct)
        return true
      else
        return false
      end
    end # nested function to_next_clove

    there_and_back!(clove_direct)
    while to_next_clove!(general_direct) && there_and_back!(clove_direct)
    end
  end # function comb!

  return (;snake!, labirint_snake!, comb!, spiral!)
end # function interface_trajectories----------------------------------
```

Тогда, например, заставить Робота пройти "змейкой" по ограниченному полю без внутренних перегородок и всюду поставить маркеры можно будет так:

```julia
using HorizоnSideRobot
robot = Robot
robot = intrface_robot(robot)
traectories = interface_trajectories(robot)
line = interface_line(robot.move!)
trajectoties.snake!(Ost,Nord) do side
  robot.putmarker!()
  line.movements!(robot.putmarker!, side)
end
```