# Лекция 9 Обобщенное программирование в функциональном стиле (продолжение)

- [Лекция 9 Обобщенное программирование в функциональном стиле (продолжение)](#лекция-9-обобщенное-программирование-в-функциональном-стиле-продолжение)
  - [Обобщенные функции, перемещающие Робота по различным специальным траекториям, и вспомогательный исполнитель, обеспечивающий при этом обход внутренних изолированных перегородок прямоугольной формы](#обобщенные-функции-перемещающие-робота-по-различным-специальным-траекториям-и-вспомогательный-исполнитель-обеспечивающий-при-этом-обход-внутренних-изолированных-перегородок-прямоугольной-формы)
  - [Примеры решения задач, в условиях которых на поле имеются внутренние перегородки прямоугольной формы, с использованием функции высшего порядка `interface_rectangular_borders`](#примеры-решения-задач-в-условиях-которых-на-поле-имеются-внутренние-перегородки-прямоугольной-формы-с-использованием-функции-высшего-порядка-interface_rectangular_borders)
    - [Подсчет числа маркеров  в простом лабиринте](#подсчет-числа-маркеров--в-простом-лабиринте)
    - [Поиск маркера на неограниченном поле по спирали при наличии прямолинейных перегородок (конечной длины)](#поиск-маркера-на-неограниченном-поле-по-спирали-при-наличии-прямолинейных-перегородок-конечной-длины)
    - [Поиск маркера на неограниченном поле по спирали при наличии конечных прямоугольных перегородок](#поиск-маркера-на-неограниченном-поле-по-спирали-при-наличии-конечных-прямоугольных-перегородок)
    - [Поиск маркера на неограниченном поле по спирали при наличии прямолинейных полубесконечных перегородок](#поиск-маркера-на-неограниченном-поле-по-спирали-при-наличии-прямолинейных-полубесконечных-перегородок)

## Обобщенные функции, перемещающие Робота по различным специальным траекториям, и вспомогательный исполнитель, обеспечивающий при этом обход внутренних изолированных перегородок прямоугольной формы

На прошлой [лекции 8](../8/Лекция-8.md) были спроектированы несколько функций высшего порядка, возвращающих интерфейсы соответствующих исполнителей, обеспечивающих перемещения Робота как по прямолинейным, так и по более сложным специальным траекториям. При этом эти функции являются обобщенными, что, позволяет их использовать для решения самых разнообразных задач. Опредеделения этих функций высшего порядка находятся в файле ["8/functional_robot.jl"](../8/functional_robot.jl).

Однако до сих пор с помощью этих функций мы рещели только задачи, в условиях которых на поле отсутствовали внутренние перегородки. Теперь мы хотим расширить круг решаемых задач и на случай, когда на поле допускается присутствие внутренних изолированных перегородок прямоугольной формы или перегородок в виде отрезков (вырожденные прямоугольники). 

Для этого мы воспользуемся тем, что разработанные нами функции (составляющие интерфейсы сооответствующих вспомогательных исполнителей) являются обобщёнными. Поэтому, единственное, что требуется сделать, это определить ещё одного исполнителя, интерфейс которого будет состоять всего из одной функции `move!(side)`, и эта функция должна будет обеспечивать перемещение Робота в заданном направлении в ближайшую доступную клетку поля. Т.е., если рядом с Роботом перегородки нет, то выполнение этой функции должно приводить просто к перемещению Робота в соседнюю клетку, но если рядом с Роботом имеется препятствующая такому перемещению перегородка, то эта функция должна перемещать Робото вогруг пререгородеи в ближайшую доступную в заданном направлении клетку - это в случая, если перегородка является внутренней. В случае внешней перегродки Робот должен оставаться на месте. И в любом случае функция `move!(side)` будет возвращать логическое значение:  `true` - если перемещение Робота состоялось, и `false` - в противном случае.

Вот опеделение функции высшего порядка, возвращающей требуемый интерфейс, и которе мы теперь добавим в файл ["9/functional_robot.jl"](functional_robot.jl):

```julia
"""
interface_rectangular_borders(robot)

-- robot - функциональный интерфейс (именованный кортеж), вулючающий функции: isborder, move!

-- возвращает кортеж из функций
    move!(side)::Bool, выполняющую перемещение Робота в ближайшую доступную клетку в направлении side и возвращающую true,
    если доступная клетка существует, и оставляющую Робота на месте и возвращающую false - в противном случае - выполняет
    (И, ВОЗМОЖНО, ДЕЛАЮЩУЮ ЧТО-ТО ЕЩЁ)

    movements!(side) - перемещает Робота "до упора" в заданном направлении
    movements!(side, num_steps::Integer) - перемещает Робота в заданном направлении на заданное число шагов
    movements!(action!::Function, side) - перемещает Робота "до упора" в заданном направлении
    movements!(action!::Function, side, num_steps::Integer) - перемещает Робота в заданном направлении на заданное число шагов

    get_num_movements!(side) - перемещает Робота "до упора" в заданном направлении и возвращает число сделанных шагов
    get_num_movements!(action!::Function, side) - перемещает Робота "до упора" в заданном направлении и возвращает число сделанных шагов

при этом в соответствующих случаях здесь после каждого шага выполняется action!()

Все функци, составляющие возвращаемый интерфейс, перемещают Робота прямолинейно, выполняя при этом обход всех встречающихся на пути 
внутренних прямоугольных перегородок.
"""
interface_rectangular_borders(robot) = begin
    line = interface_line(robot.move!)

    function move!(side)::Bool
    # Перемещает Робота на один шаг в заданном направлении с обходом прямоугольной перегородки, если она стоит на пути
        num_steps = 0
        while robot.isborder(side) && !robot.isborder(left(side))
            robot.move!(left(side)) #!!!
            num_steps+=1
        end
        #УТВ: Робот стоит за краем перегородки, которую пытался обойти в поперечном направлении, или в углу, если это была внешняя рамка 

        ansver=robot.move!(side)
        if num_steps==0 # Робот не выполнял попытки обхода (перегородки на его пути не было)
            return ansver # == true
        end
        while robot.isborder(right(side))
            if robot.isborder(side)
                ansver = false # Робот уперся в угол (перегородка не является прямоугольной!)
                while robot.isborder(right(side))
                    robot.move!(inverse(side))
                end
                #УТВ: Робот возвращен на уровень переднего фронта перегородки
                break
            end
            #УТВ: перегородка, возможно, является прямоугольной
            robot.move!(side)
        end
        #УТВ: Робот прошел сбоку от перегородки за её пределы
        line.movements!(right(side), num_steps)
        #УТВ: Робот возвращен на главную линию своего движения
        return ansver
    end

    return (move! = move!, interface_line(move!)...) # - этот интерфейс состоит из новой функции move! и всех функций интерфейса interface_line, посторенных на основе этой новой функции move!

end # interface_rectangular_borders -------------------------------------------
```

Теперь, можно создать соответствующего исполнителя, например:

```julia
using HorizonSideRobots
include("9/functional_robot.jl")

robot = Robot(...)

robot = interface_protected_robot(robot)

rectangular_borders = interface_rectangular_borders(robot)

line1 = interface_line(robot.move!)

line2 = interface_line(rectangular_borders.move!)
```

Тогда

```julia
line1.move!(Ost)
```

переместит Робота на восток до первой встретившейся на пути перегородки.

Но уже

```julia
line2.move!(Ost)
```

переместит Робота в заданном направлении вплоть до внешней рамки, с обходом попадающихся на пути внутренних перегородок прямоугольной формы) с помощью обобщенной функции `line.move!`.

## Примеры решения задач, в условиях которых на поле имеются внутренние перегородки прямоугольной формы, с использованием функции высшего порядка `interface_rectangular_borders`

Следующие примеры показывают как с помощью этого нового исполнителя могут быть решены многие задачи, в условиях которых допускается наличие внутренних перегородок в виде изолированных прямоугольников (отрезков)

### Подсчет числа маркеров  в простом лабиринте

Пусть начальная обстановка имеет вид: ![example_9.1.sit.png](example_9.1.sit.png)

и требуеся посчитать число маркеров в простом лабиринте, внутри которого могут находиться также внутренние изолитрованные перегородки прямоугольной формы.

Простым мы называем лабиринт, вертикальные участки границы которого любыми горизонтальными прямыми пересекает ровно два раза (или ни разу не пересекаются).

Программный код с решением задачи находится в файле ["example_9.1.jl"](example_9.1.jl)

### Поиск маркера на неограниченном поле по спирали при наличии прямолинейных перегородок (конечной длины)

При отсутствии на поле перегородок эта задача решена в "Практика 8". Рассмотрим теперь эту задачу при условии, что на поле могут находиться перегродки в форме верикальных или горизонтальных отрезков, но не прямоугольников.

Интерфейс, возвращаемый функцией высшего порядка `interface_rectangular_borders(robot)`, позволяет справиться и с задачей поиска маркера на неограниченном поле и в случае, когда на поле имеются перегородки прямолинейной формы конечной длины (вырожденные прямоугольники). Вот пример соответствующей обстановки: ![Маркер на неограниченном поле](example_9.2.sit.png)

Программный код с решением этой задачи находится в файле ["example_9.2.jl"](example_9.2.jl)

### Поиск маркера на неограниченном поле по спирали при наличии конечных прямоугольных перегородок

Функции высшего порядка `spiral!`, определенная в возвращающей её функции высшего порядка `interface_traectories(robot)` в файле ["functional_robot.jl"](functional_robot.jl), аналогично предыдущему примеру может быть использована и для поиска маркера на неограниченном поле, при наличии на нём изолированных прямоугольных пергородок конечной длины.

Ранее эта задача была решена  только для случая наличия вырожденных прямоугольных перегородок (отрезков). В случае же прямоугольных перегородок общего вида это решение не годится.

Сложность здесь состоит в том, что если прямоугольник, который на очередном шаге требуется обойти, не вырождаен в отрезок, то невозможно будет переместиться в соседнюю клетку. Обходы же прямоугольных перегородок с помощью функции `move!` из интерфейса, возвращаемого `interface_rectangular_borders(robot)`, тоже не решает проблемы, потому что при движении по спирали конечное положение Робота (после выполнения одного шага) не всегда должно быть с другой стороны прямоугольника: оно также может оказаться и на tuj боковой стороне прямоугольника и даже - на стороне, первоначально обращенной к Роботу.

Но если перед тем, как сделать очередной шаг с обходом прямоугольника (в некотором направлении), предварительно определить его размеры, а также если вычислять деакртовы коорднаты текущего положения Робота относительно центра "раскручиваемой спирали", то можно вычислять конечное положение Робота при обходе каждого прямоугольника и сразу перемещать в него Робота. И при этом надо еще будет вычислить сколько воображаемых "шагов по спирали" надо пропустить, чтобы снованачать перемещать робота по продолжению спирали.

Все эти действия следует оформить в виде вспомогательной функции, которую надо будет передавать через соответсвующий параметр в функцию высшего порядка `spiral!`. Предлагается самостоятельно получить решение этой задачи.

### Поиск маркера на неограниченном поле по спирали при наличии прямолинейных полубесконечных перегородок

Чтобы в задаче поиска маркера на неограниченном поле справиться с наличием полубесконечных прямолинейных перегородок,  функции `move!` из интерфейса, возвращаемого `interface_rectangular_borders(robot)`, будет уже не достаточно. Для этого случая потребуется соответствующим образом переопределить функции move!.

Программный код с решением этой задачи находится в файле ["example_9.3.jl"](example_9.3.jl).
