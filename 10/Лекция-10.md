# Лекция 10

(функциональный стиль, продолжение, начало в лекции 7)

- [Лекция 10](#лекция-10)
  - [Mодули](#mодули)
  - [Реализация (создание) интерфейса исполнителя "Декарт" с помомощью функции высшего порядка](#реализация-создание-интерфейса-исполнителя-декарт-с-помомощью-функции-высшего-порядка)
  - [Реализация (создание) интерфейса исполнителя "Робот Декарт" с помомощью функции высшего порядка](#реализация-создание-интерфейса-исполнителя-робот-декарт-с-помомощью-функции-высшего-порядка)
  - [Пльзовательские типы данных, струтуры](#пльзовательские-типы-данных-струтуры)
  - [Реализация исполнителя "Декарт" на основе соответствующей структуры](#реализация-исполнителя-декарт-на-основе-соответствующей-структуры)
  - [Реализация (создание) интерфейса исполнителя "Робот-Декарт" с помомощью структуры](#реализация-создание-интерфейса-исполнителя-робот-декарт-с-помомощью-структуры)

Средства языка програмирования для структурной организации программного кода

- Модули
- Функции высшего порядка, возвращающие интерфейсы для взаимодействия с замкнутыми объектами
- Пользовательские типы данных (структуры)

## Mодули

Модули предназначены, в первую очередь, для создания изолированных пространств имён, в которые помещаюттся функции, глобальные переменные, пользовательские типы данных. Отдельные пространства имен требуются для того, чтобы в больших проектах не возникали конфликты имён. Достигается это за счет того, что имя любой сущности помещенной в модуль при необходимости может быть сотавным: 
"ИмяМодуля.Имя_сущности_определенной_в_модуле"
Это основное и очень важное назначение модулей.

Модуль, в котором инкапсулированы глобальные переменные, и из которого экспортируются функции, взаимодействующие с этими глобальными переменными, представляют собой исполнителя. Его состояние определяется текущими значениями его глобальных переменных, а его командный интерфейс составляют экспортируемые из него функции.

Если в модуле нет глобальных переменных, но из него экспортируются некоторые замыкания, то такой модуль тоже представляет собой исполнителя, внутреннее состояние которого определяется внутренним состоянием этих замыканий.

Примером такого исполнителя является спроектировнный нами ранее модуль "Декарт" (см. [практика 7](../7/Практика-7.md)):

```julia
module Decart
    using HorizonSideRobots
#=
Предполагается, что в пространстве имен Main определена функция inverse, например, путем вставки из файла "roblib.jl"
=#
    export init, move!, coordinates

    X_COORD=0
    Y_COORD=0

    function init(x,y)
        global X_COORD, Y_COORD
        X_COORD=0
        Y_COORD=0
    end

    function move!(r,side)
        global X_COORD, Y_COORD
        if side==Nord
            Y_COORD+=1
        elseif side==Sud
            Y_COORD-=1
        elseif side==Ost
            X_COORD+=1
        else # side==West
            X_COORD-=1
        end
        HorizonSideRobots.move!(r,side)
    end

    coordinates() = (X_COORD, Y_COORD)
end # module
```

Такой (на основе модулей) подход к проектированию вспомогательных исполнителей характерен для языка C, но в языке Julia имеются и другие, более гибкие средства, для решения такого рода задач, к рассмотрению котрых мы сейчас и перейдем

## Реализация (создание) интерфейса исполнителя "Декарт" с помомощью функции высшего порядка

Программный код, реализующий исполнителя, представляющего значение текущих декартовых координат, и умеющего возвращать значение этих координат, а также изменять значение координат на значение координат одной из 4-х соседних клеток, в зависимостимот значения аргумента типа HorizonSide (этот код находится в файле ["interface_decart.jl"](interface_decart.jl)):

```julia
function interface_decart(coords::NamedTuple{(:x,:y),Tuple{Int,Int}})
    x = coords.x
    y = coords.y

    function coordinates!(side::HorizonSide)
        if side == Ost
            x+=1
        elseif side == West
            x-=1
        elseif side == Nord
            y+=1
        else
            y-=1
        end
        return (x=x,y=y)
    end

    coordinates() = (x=x,y=y)

    return (coordinates = coordinates, coordinates! = coordinates!)
end
```

Стоит обратить внимание, что функция высшего порядка `interface_decart` возвращает два замыкания своих локальных переменных. Первому из них присвоено имя `coordinates` (эта функция не имеет оргументов), а вторуму -  `coordinates!` (эта функция имеет ровно один аргумент типа `HorizonSide`).

Протестировать этот код можно так:

```julia
decart = interface_decart((x=0,y=0))
decart.coordinates() |> println       # (x=0,y=0)
decart.coordinates!(Nord) |> println  # (x=0,y=1)
```

Функция высшего порядка `interface_decart(coords)` возвращает командный интерфейс исполнителя (в виде именованного кортежа), который хранит в памяти текущие координаты, и умеет их возвращать, или - изменять, в зависимости от значения соответствующего аргумента (`side`). Но непосредственно с Роботом этот исполнитель не связан, он призван выполнять вспомогательную функцию - отслеживания текущих координат Робота.

## Реализация (создание) интерфейса исполнителя "Робот Декарт" с помомощью функции высшего порядка

Чтобы связать исполнителя "Декарт" с перемещениями Роботом определим теперь следующую функцию высшего порядка (это определение находится в файле ["interface_robot_decart.jl"](interface_robot_decart.jl)):

```julia
interface_robot_decart(robot, decart) =
    # robot = inteface_save_robot(...)
    # decart = interface_decart(...)
    (
        move! =  
            side -> if robot.move!(side) == true
                        decart.coordinates!(side)
                        true
                    end,
        isborder = robot.isborder,
        putmarker! = robot.putmarker!,
        ismarker = robot.ismarker,
        temperature = robot.temperature,
        show! = robot.show!,
        set_situation! = robot.set_situation!,
        coordinates = decart.coordinates
    )
```

Эта функция высшего порядка принимает два аргумента, представляющие собой командные интерфейсы (именованные кортежи) двух исполнителей: "Робота" и "Декарта", и возвращает кортеж, соединяющий оба этих интерфейса, причем функция `move!` командного интерфейса Робота переопределяется при этом так, что при перемещении Робота в заданном направлении будет происодить изменение его текущих координат, представленных исполнителем "Декарт".

С помощью этого нового интерфейса командовать Роботом теперь можно, например, так:

```julia
using HorizonSideRobots
include("functional_robot.jl")
include("interface_decart.jl")
include("interface_robot_decart.jl")
robot = Robot()
robot = interface_protected_robot(robot) # - теперь robot - это не объект типа Robot, а соответствующий интерфейс (именованный кортеж)
decart = interface_decart((x=0,y=0))
robot_decart = interface_robot_decart(robot, decart)

robot_decart.coordinates() |> println # (x=0,y=0)
robot_decart.move!(Ost)
robot_decart.coordinates() |> println # (x=1,y=0)
```

## Пльзовательские типы данных, струтуры

Структуры - это пользовательские типы данных, в общем случае составленные из нескольких типов данных. Например

```julia
struct User
    name::String
    code::Int
end
```

Здесь определен новый (пользовательский) тип данных. `User` - это имя этого типа данных (принято типы данных именовать с загланой буквы). В данном случае созданный тип данннных состоит из двух плей: типа `String` и `Int64` соответственно. В принципе, число полей в структуре может быть любым, включая 0 (структура может быть пустой). Типы полей структуры тоже могут быть любыми, но желательно чтобы они были конкретными, а не абстрактными - тогда компилятор сможет генеровать более эффективный код.

Создать объект типа `User` можно так:

```julia
user = User("Nikolay", 001)
```

Объект всегда создаётся с помощбю конструктора типа, т.е. с помощю функции, предназначеннно специально для создания объектов данного типа. Имя конструктора всегда совпадает с именем типа.

В данном случае использовался конструктор "по умолчанию", но можно опредялять и пользовательский консруктор, например:

```julia
struct User
    name::String
    code::Int
    User(name)=new(name, Int(trunc(rand()*1000)))
    User(name,code)=new(name, code) # имена аргуметов конструктора не обязаны совпадать с именами полей структуры
end
```

Здесь имеется 2 варианта конструктора: с одним аргументом - тогда код шенерируется с помощью датчика случайных чисел, и с двумя аргументами - в точности повторяя конструктор "по умолчанию".

Но если в структуре оставить только первый вариант конструктора (с одним аргументом), то вариант "по умолчанию" не будет работать, поэтому его пришлось явно запрограммировать.

Во всех случаях объект размещается в памяти с помощью встроенного оператора `new`, который всегда должен иметь ровно столько аргументов, сколько имеется полей у соответствующей структуры. Этими аргументами инизиализируются поля создаваемого объекта, а их последовательность должна соответствовать прядку следования полей в самой структуре. Оператор new можно использовать только в теле какого-либо конструктора.

Пусть создан объект

```julia
user = User("Ivan", 123)
```

Тогда

```julia
user.name |> println # Ivan
user.code |> println # 123
```

Но попытка присвоить какому-либо полю структуры нового значения, например

```julia
user.code 200
```

приведет к ошибке, потому что наша структура неизменяемая. Чтобы поля структуры можно было изменять, в её определении должно присутствовать слово `mutable` (изменяемая):

```julia
mutable struct User
    name::String
    code::Int
    User(name)=new(name, Int(trunc(rand()*1000)))
    User(name,code)=new(name, code)
end
```

Неизменяемые структуры позволяют компилятору генерировать более эффективный код, так что если это важно, то без весткой необходимости делать сруктуры изменяемыми не стоит.

Для работы с данными, содержащимися в объектах пользовательского типа должны быть определены специальные функции. Допустим, что в нашем примере, мы бы хотели иметь возможность прверить, принадлежит ли код данного пользователя заданному диапазону кодов. Тогда мы могли бы написать, например, функцию:

```julia
isvalid(user::User) = (user.code in 1:100)
```

Все функции в совокупности, предназначенные для работы с пользовательским типом данных, образуют функциональный интерфейс, для работы с каждым объектом данного типа.

Эти функции не помещаются внутрь структыру, а определяются вне её (внутри структуры определяется только конструктор).

Часто структуру вместе с её функциями оборачивают в отдельный модуль, но это делать не обязательно.

## Реализация исполнителя "Декарт" на основе соответствующей структуры

Реализовать исполнителя "Декарт" можно было бы еще и на основе проектирования соответствующего пользовательского типа данных (следующий код находится в файле ["type_decart.jl"](type_decart.jl))

```julia
using HorizonSideRobots

mutable struct Decart
    coordinates::NamedTuple{(:x,:y),Tuple{Int,Int}}

    Decart(coordinates::NamedTuple{(:x,:y),Tuple{Int,Int}}) = new(coordinates)
end

function coordinates!(decart::Decart, side::HorizonSide)
    if side == Ost
        decart.coordinates.x+=1
    elseif side == West
        decart.coordinates.x-=1
    elseif side == Nord
        decart.coordinates.y+=1
    else
        decart.coordinates.y-=1
    end

    return (x=decart.coordinates.x, y=decart.coordinates.y)
end

coordinates(decart::Decart) = decart.coordinates
```

Функциональный нтерфейс в данном случае составляют две функции: `coordinates!(::Decart, ::HorizonSide)` и `coordinates(::Decart)`

Протестировать эти функции можн, например, так:

```julia
include("type_decart.jl")
decart = Decart((x=0,y=0))

coordinates(decart) |> println          #  (x=0,y=0)
coordinates!(decart, Nord) |> println   #  (x=0,y=1)
```

Стоить обратить внимание на полное соответствие данной реализации исполнителя "Декарт" с реализованной ранее в функциональном стиле (см.выше).

Важно также заметить, что в обоих случаях данные и работающие с ними функции представляют собой единое целое (исполнителя). Только в случае функционального программирования к функциям добавляются данные (функции замыкают эти данные), а в случае объектно-ориентированного стиля программирования, наоборот, к данным добавляются функции, получающие эти данные в иде аргументов.

## Реализация (создание) интерфейса исполнителя "Робот-Декарт" с помомощью структуры

```julia
using HorizonSideRobots

struct RobotDecart
    robot::Robot
    decart::Decart
    RobotDecart(robot, coords) = new(robot, Decart(coords))
    RobotDecart(robot) = RobotDecart(robot, (x=0, y=0))
end

HorizonSideRobots.move!(robot::RobotDecart, side) = move!(robot.robot, side)
HorizonSideRobots.isborder(robot::RobotDecart, side) = isborder(robot.robot, side)
HorizonSideRobots.putmarker!(robot::RobotDecart) = putmarker!(robot.robot)
HorizonSideRobots.ismarker(robot::RobotDecart) = ismarker(robot.robot)
HorizonSideRobots.temperature(robot::RobotDecart) = temperature(robot.robot)
HorizonSideRobots.show!(robot::RobotDecart) = show!(robot.robot)


Чтобы протестировать эти функции, можно сделать следующее:

```julia
robot = Robot(animate=true)
robot_decart = RobotDecart(robot)

coordinates(robot_decart) |> println # (x=0, y=0)
move!(robot_decart, Nord)
coordinates(robot_decart) |> println # (x=0, y=1)
```

Но теперь, когда у нас создан объект `robot_decart` типа `RobotDecart`, мы снова можем воспользоваться определениями из файла ["functional_robot.jl"](functional_robot.jl), например:

```julia
protected_robot = interface_protected_robot(robot_decart)
line = interface_line(protectd_robot.move!)

line.movements!(Ost)

robot_decart.coordinates() |> println # - будут выведены координаты Робота, переместившегося до упора на восток
```
